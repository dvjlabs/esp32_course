{"config":{"lang":["it"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"MicroPython && ESP32","text":"<p>Un semplice corso per parlare di:</p> <ul> <li> <p>il microcontrollore ESP32: un dispositivo programmabile alla nostra portata</p> </li> <li> <p>L'interprete MicroPython: un interprete Python ridotto, adatto per i microcontrollori</p> </li> <li> <p>Thonny: il nostro editor Python preferito!!! Qui utilizzato (anche) per interagire con un microcontrollore</p> </li> <li> <p>sensori ed elettronica: vuoi implementare un semaforo? Una calcolatrice? Una stazione meteo? Un allarme? Dovrai far interagire alcuni sensori con il tuo microcontrollore e dovrai gestirli tramite il tuo codice. Sar\u00e0 divertente!!!</p> </li> </ul> <p>Poi... per il divertimento di tutti, allestiremo anche una sezione di tutorials, per (provare a) fare cose in autonomia!!</p> <p>Cominciamo!</p> <p>Il Corso! I Tutorials!</p> <p> </p>"},{"location":"corso/00_intro/","title":"Introduzione","text":"<p>Giusto due parole per introdurre:</p> <ul> <li>Il MicroControllore ESP32</li> <li>Le specifiche del dispositivo in dotazione alla scuola</li> <li>MicroPython</li> </ul> <p>Introduciamo i concetti in senso generale... se avete fretta e volete passare subito alla fase operativa... il prossimo capitolo \u00e8 per voi.</p> <p>Iniziamo!!</p>"},{"location":"corso/00_intro/#il-microcontrollore-esp32","title":"Il MicroControllore ESP32","text":"<p>ESP32 \u00e8 un microcontrollore a basso costo, con Wifi e bluetooth integrato, oltre che un'interfaccia programmabile per la gestione di vari sensori collegati ad esso.</p> <p>MicroControllore</p> <p>Un MicroControllore (MCU) \u00e8 un dispositivo elettronico integrato in un unico circuito, in grado di eseguire in maniera autosufficiente un determinato software.</p> <p>Si presenta come alternativa al MicroProcessore (CPU) che \u00e8 un dispositivo con maggiore potenza di calcolo, ma con la continua necessit\u00e0 di interfacciarsi con periferiche esterne, tipo RAM, ROM, etc.. per la selezione del software da eseguire.</p> <p>Un microcontrollore, una volta che vi viene caricato un software da eseguire, lo esegue all'infinito dal momento in cui viene acceso al momento in cui esso viene spento. \u00c8 dunque la soluzione ideale per la realizzazione di qualsiasi dispositivo elettronico: una calcolatrice, la macchina del caff\u00e8, una lavatrice moderna, la stampante 3D... sono tutti oggetti realizzati tramite MCU!</p> <p>Risulta dunque evidente quanto i MicroControllori rappresentino uno dei mattoni fondamentali dell'evoluzione dell'informatica e delle telecomunicazioni conosciuta con il nome di Internet of Things.</p> <p></p>"},{"location":"corso/00_intro/#specifiche-tecniche","title":"Specifiche tecniche","text":"<p>Attenzione!</p> <p>Le informazioni qui sotto sono roba da nerd... leggetele con il rischio di appassionarvi a certe precisazioni!!</p> <p>La ESP32 in dotazione a scuola \u00e8 una <code>ESP32-WROOM-32 dLOIN32</code> (se avete gli occhi buoni... lo potrete leggere sul dispositivo stesso):</p> <ul> <li>Deve essere alimentato a 3.3 Volt</li> <li>Consuma fino a 500mA</li> <li>Il controllore ESP32-WROOM-32, \u00e8 un dual-core a 32 bit Xtensa LX6</li> <li>Ha una frequenza di 240 Mhz</li> <li>La memoria predefinita \u00e8 una ROM di 32 Mb a 40 Mhz</li> <li>Il WiFi supporta i protocolli 802.11 b/g/n, fino a 150 Mbps</li> <li>Ha Bluetooth 4.2 BR/EDR e BLE</li> <li>Ricevitore NZIF</li> <li>Supporta le seguenti cifrature: WAPI, WEP, TKIP, AES, SHA-2, RSA, ECC</li> <li>Input analogici (ADC): 12, a 12-bit ognuna</li> <li>Output analogici (DAC): 2, a 8-bit ognuna</li> <li>Interfacce: GPIO, UART, I2C, I2S, SPI, PWM, Touch, Ethernet MAC, SDcard, SDIO, IrDA</li> <li>UART baud rate: fino a 5MBit/s</li> <li>Output LED programmabile: al GPIO 5</li> <li>Supporta: ARDUINO, NodeMCU, MicroPython, ESP-IDF</li> </ul>"},{"location":"corso/00_intro/#micropython","title":"MicroPython","text":"<p>MicroPython \u00e8 una implementazione del linguaggio Python progettata per essere eseguita sui microcontrollori. Uno degli obiettivi del progetto \u00e8 quello di ricercare la miglior compatibilit\u00e0 possibile con il Python normale, per semplificare l'apprendimento e la realizzazione di software che colleghi i due mondi <code>desktop</code> e <code>sistemi embedded</code>.</p> <p>Il sito ufficiale di MicroPython \u00e8 (incredibilmente): https://micropython.org (sotto, uno screenshot)</p> <p></p> <p>Poich\u00e9 l'interprete va eseguito direttamente sul microcontrollore, va scaricato dal sito l'interprete adatto e installato su di esso.  Il prossimo capitolo spiega proprio questo!</p> <p>Domanda</p> <p>A proposito... sapete qual \u00e8 l'editor Python pi\u00f9 semplice ed adatto per la programmazione di microcontrollori basati su MicroPython??</p> <p>Se avete risposto Thonny, avete dato la risposta esatta!!!</p> <p> </p>"},{"location":"corso/01_prime_operazioni/","title":"Prime Operazioni","text":"<p>In questo capitolo installeremo il firmware MicroPython su ESP32 e faremo un primo test di funzionamento. L'obiettivo di questo capitolo \u00e8 essere operativi... le spiegazioni sul codice (Micro)Python e il dispositivo ESP32... arrivano dopo!</p>"},{"location":"corso/01_prime_operazioni/#installazione-firmware","title":"Installazione Firmware","text":"<p>Per caricare il firmware MicroPython Thonny offre una comodissima interfaccia, che ci permette di scaricarlo e installarlo automaticamente!!!</p> <ul> <li>Aprite <code>Thonny</code></li> <li>Dal men\u00f9 <code>ESEGUI</code>, seleziona <code>CONFIGURA L'INTERPRETE</code></li> <li>Seleziona <code>MicroPython (ESP32)</code> (vedi figura sotto)</li> </ul> <p></p> <p></p> <p></p> <p>La giusta porta COM</p> <p>Come vedete in figura, la MCU utilizza una porta COM supportata dal driver Silicon Labs CP210x USB to UART Bridge.</p> <p>Se nel tuo computer manca... chiedi al prof!!!</p> <p></p> <ul> <li>Adesso selezionate <code>Installa o Aggiorna MicroPython</code></li> <li> <p>Si aprir\u00e0 la finestra qui sotto. Vanno selezionate:</p> <ul> <li>la porta su cui \u00e8 collegata il microcontrollore ESP32</li> <li>La famiglia della MCU (ESP32)</li> <li>La variante (EspressIf - ESP32 / WROOM)</li> <li>la versione (dovrebbe apparire automaticamente l'ultima installabile)</li> </ul> </li> <li> <p>Poi clicca <code>installa</code></p> </li> </ul> <p></p> <p></p> <p></p> <p>... attendi fiducioso un minutino buono...</p> <p>Al termine della procedura dovrebbe apparire l'interprete MicroPython nella shell di Thonny</p> <p></p> <p></p> <p></p> <p>Ecco fatto!</p> <p>Siamo pronti per il primo esempio!</p>"},{"location":"corso/01_prime_operazioni/#primo-programma","title":"Primo programma","text":"<p>Di solito i primi programmi che si scrivono testando un nuovo ambiente sono i famigerati HelloWorld! In questo caso particolare invece, andremo ad accendere e spegnere (ad intervalli programmati) il led fisico (detto, appunto, programmabile) disponibile nell'ESP32.</p> <p>Il programma scriver\u00e0 inoltre su <code>REPL</code> una notifica del tipo \"LED Acceso\" o \"LED Spento\".</p> <p>REPL</p> <p><code>Read Eval Print Loop</code> \u00e8 una caratteristica tipica dei linguaggi interpretati che forniscono accesso all'interprete da console. In Python REPL viene identificato dai 3 maggiori <code>&gt;&gt;&gt;</code> ed \u00e8 effettivamente un punto di accesso all'interprete stesso.</p> <p>Tu scrivi un comando, lui lo legge (Read), lo valuta (Eval), visualizza un output come risultato della sua valutazione (Print) e infine ripresenta il prompt iniziale <code>&gt;&gt;&gt;</code> (Loop).</p> <p>Il programma ci serve come esempio per prendere confidenza con i mondi MicroPython ed ESP32: non \u00e8 importante adesso quello che fa il programma, ma riuscire a capire tutte le operazioni da svolgere. Per questo ho deciso di dividere le operazioni in step successivi. Andiamo!!</p> <p>Step 0</p> <p>Se non lo hai gi\u00e0 fatto, connetti il tuo ESP32 al computer, apri Thonny e cambia l'interprete Python a <code>MicroPython (ESP32)</code>.</p> <p>Step 1</p> <p>Copia su Thonny il seguente codice:</p> <pre><code>from machine import Pin\nimport time\n\n# Il pin 5 \u00e8 quello del LED programmabile\n# Ricordate?\nled = Pin(5, Pin.OUT)\nled.off()\n\nwhile True:\n    led.on()\n    print(\"LED Acceso\")\n    time.sleep(1)\n\n    led.off()\n    print(\"LED Spento\")\n    time.sleep(1)\n</code></pre> <p>Step 2</p> <p>Adesso salva il file come <code>led_test.py</code> dentro la memoria dell'ESP32. Per farlo:</p> <ul> <li>clicca SALVA</li> <li>Dall'interfaccia seleziona Dispositivo MicroPython</li> </ul> <p></p> <p></p> <p></p> <ul> <li>Salva il file nella MCU con nome <code>led_test.py</code> o come preferisci.</li> </ul> <p>Step 3</p> <p>Esegui il codice, premendo <code>F5</code> oppure selezionando l'azione <code>Run current script</code>: dovresti vedere le scritte <code>LED Spento</code> e <code>LED Acceso</code> alternate di un secondo mentre il LED si accende e si spegne.</p> <p>Ecco fatto!</p>"},{"location":"corso/01_prime_operazioni/#bootpy","title":"boot.py","text":"<p>Sicuramente avrai notato che nel filesystem dell'ESP32 \u00e8 presente un file chiamato <code>boot.py</code>. Questo file viene eseguito automaticamente... al boot del dispositivo. Quindi il poco codice che va l\u00ec dentro pu\u00f2 servire per le prime indispensabili operazioni irrinunciabili:</p> <ul> <li>collegarsi ad una rete wifi,</li> <li>attivare il bluetooth,</li> <li>far partire webrepl (qualunque cosa esso sia)...</li> </ul> <p>Basta!</p> <p>Il boot \u00e8 l'operazione pi\u00f9 importante per un microcontrollore che, dopo questa fase, si mette in uno stato di ripetizione infinita del codice che dovr\u00e0 eseguire finch\u00e9 il dispositivo \u00e8 acceso.</p> <p>Attenti a quello che scrivete nel file \"boot.py\"! Qualunque errore l\u00ec si tradurra in problemi all'avvio e in grandi difficolt\u00e0 per la risoluzione! Qualunque codice che ci copiate va testato ed eseguito prima su un altro file e poi spostato l\u00ec dentro.</p>"},{"location":"corso/01_prime_operazioni/#mainpy","title":"main.py","text":"<p>Se volete fare in modo che, appena finite le operazioni di boot, il microcontrollore cominci ad eseguire un codice qualunque, il file ove dovete salvarlo si chiama <code>main.py</code>.</p> <p>Il codice l\u00ec dentro:</p> <ul> <li>sar\u00e0 eseguito subito dopo il boot, ovvero quando il dispositivo \u00e8 gi\u00e0 pienamente funzionante.</li> <li>sar\u00e0 facile da stoppare con un semplice CTRL + C oppure con lo stop del micropython.</li> <li>blah blah (\u00e8 meglio e basta! Se devi far partire codice all'avvio del dispositivo, mettilo in un file main.py)</li> </ul> <p> </p>"},{"location":"corso/02_micropython/","title":"MicroPython","text":"<p>Come abbiamo gi\u00e0 detto, MicroPython \u00e8 un interprete progettato appositamente per i microcontrollori e che cerca di emulare le funzionalit\u00e0 base di Python. Sostanzialmente sono implementati due gruppi di funzionalit\u00e0:</p> <ul> <li>alcune delle librerie della Python Standard Library</li> <li>alcune funzionalit\u00e0 specifiche per i microcontrollori.</li> </ul> <p>Documentazione Ufficiale</p> <p>Il progetto MicroPython espone nel suo sito web la documentazione ufficiale di riferimento per il progetto MicroPython.</p> <p>Se volete curiosare... fate pure. Lo spirito con cui ho messo i link mirati qui sotto \u00e8 invece quello di consultare una documentazione specifica secondo necessit\u00e0.</p>"},{"location":"corso/02_micropython/#funzionalita-micro-ified","title":"Funzionalit\u00e0 micro-ified","text":"<p>I moduli elencati qui, sono moduli presenti nella <code>Python Standard Library</code>, che sono stati reimplementati per funzionare in maniera analoga identica in MicroPython.</p> <p>L'elenco completo dei moduli reimplementati lo trovate al seguente link:</p> <p>In particolare, a noi potrebbero tornare utili:</p> <ul> <li><code>math</code>, per operazioni matematiche</li> <li><code>random</code>, per generare numeri pseudo-casuali</li> <li><code>socket</code>, per funzionalit\u00e0 di rete basate sul livello di trasporto</li> <li><code>time</code>, per funzioni relative a data e ora (e la utilissima funzione <code>sleep()</code>)</li> </ul>"},{"location":"corso/02_micropython/#funzionalita-specifiche","title":"Funzionalit\u00e0 specifiche","text":"<p>I moduli elencati qui sono moduli specifici per MicroPython: questi moduli nella <code>Python Standard Library</code> non ci sono!</p> <p>Tutte le funzionalit\u00e0 implementate sono documentate al seguente link.</p> <p>In particolare, mi piace mettere in eveidenza i seguenti moduli, che sicuramente prima o poi ci ritorneranno utili:</p> <p>modulo <code>machine</code> - (documentazione)  Funzioni collegate all'hardware della MCU. Permette di gestire ogni componente hardware del microcontrollore.</p> <p>modulo <code>esp32</code> (documentazione)  contiene funzionalit\u00e0 specifiche per il microcontrollore esp32</p> <p>modulo <code>micropython</code> - (documentazione)  Accesso e controllo delle librerie interne di MicroPython. Pu\u00f2 essere utilizzato per implementare funzionalit\u00e0 aggiuntive.</p> <p>modulo <code>network</code> - (documentazione)  Modulo per la configurazione della rete. Collegamento del dispositivo alla rete Wifi, del suo indirizzamento e routing.</p> <p>modulo <code>bluetooth</code> - (documentazione)  Libreria Bluetooth di basso livello. Serve (ovviamente) per connettere la MCU tramite bluetooth</p> <p>I moduli <code>network</code> e <code>bluetooth</code> saranno trattati nel capitolo relativo al networking. Qui sotto proveremo a parlare dei moduli di base.</p> <p> </p>"},{"location":"corso/03_GPIO/","title":"GPIO","text":"<p>GPIO \u00e8 l'acronimo di <code>General Purpose Input Output</code> ed \u00e8 il concetto con cui si descrive l'interazione della MCU con tutto l'hardware che \u00e8 possibile collegare ad essa. Tipicamente, il collegamento avviene per mezzo dei <code>pin</code> che contornano la MCU. </p> <pre><code>Ma quale corrispondenza c'\u00e8 fra i vari pin e il codice che possiamo scrivere con MicroPython??\n</code></pre> <p>La risposta \u00e8 semplice ma un p\u00f2 articolata. </p> <p>Prima di tutto il sistema di pin ha un ruolo e una numerazione, come vediamo nella figura sottostante</p> <p></p> <p></p> <p></p> <p>Con un pochino di esperienza capiremo al volo quali pin utilizzare e come... per adesso osserviamo pezzo per pezzo lo schema:</p> <ul> <li> <p>le scritte viola sono tutte del tipo <code>GPIOXX</code> dove <code>XX</code> \u00e8 il numero identificativo del pin in questione: quello \u00e8 l'informazione che   ci serve per interagire con il dispositivo eventualmente collegato a quel pin fisico.</p> </li> <li> <p>le scritte rosse sono solo <code>3.3v</code> oppure <code>5v</code>. Indicano il voltaggio che si pu\u00f2 ottenere collegando un dispositivo a uno di quei pin.   Ovviamente serve per alimentarlo </p> </li> <li> <p>le scritte nere <code>GND</code> (ground) indicano i pin di collegamento a terra di un circuito elettrico.</p> </li> <li> <p>le scritte grigie <code>Input Only</code> indicano che quei pin sono di collegamento unilaterale per la lettura dei dati dal dispositivo elettronico alla MCU.</p> </li> <li> <p>le linee nere che collegano le scritte ai pin hanno in alcune di esse una pulsazione! I pin che ce l'hanno supportano il <code>Pulse Width Modulation</code>,   di cui parleremo a breve.</p> </li> </ul> <p>Per adesso basta! Con questi siamo gi\u00e0 sufficientemente operativi.</p> <p>Negli esempi di codice che seguono andremo a ragionare su un sensore, un attuatore, un... hardware da collegare in qualche modo alla nostra MCU, con cui interfacciarsi osservando questa immagine di riferimento e utilizzando la libreria MicroPython necessaria.</p> <p>Proviamo!!!</p> <p> </p>"},{"location":"corso/08_il_multimetro/","title":"Il multimetro","text":"<p>Un multimetro digitale \u00e8 uno strumento che permette di misurare valori di: 1. Corrente 2. Tensione 3. Resistenza</p> <p>I multimetri digitali possono cambiare di colore e forma, ma la struttura principale \u00e8 la stessa a quella che si pu\u00f2 vedere nella figura seguente.</p> <p> </p> <p>E' composto da tre parti: 1. display 2. manopola di selezione 3. porte o contatti dove inserire le punte metalliche</p> <p>Il display di solito \u00e8 a quattro cifre e ha la possibilit\u00e0 di visualizzare un segno negativo. Alcuni multimetri hanno il display illuminato per una migliore visualizzazione in condizioni di scarsa luce. La manopola di selezione permette all'utente di impostare il multimetro per leggere diversi valori, come corrente (A) , tensione (V) e resistenza (\u03a9). Per quanto riguarda la tensione, si possono eseguire misure di tensione continua(V) e di tensione alternata (V~).  </p> <p></p> <p>Due sonde sono collegate a due porte sul frontale dell'unit\u00e0. COM sta per comune ed \u00e8 quasi sempre collegata a terra o '-' di un circuito. La sonda COM \u00e8 convenzionalmente nera, ma non vi \u00e8 alcuna differenza tra la sonda rossa e la sonda nera, sono solo di colore diverso. 10A \u00e8 la porta speciale utilizzata per misurare correnti elevate (superiori a 200mA). mAV\u03a9 \u00e8 la porta dove la sonda rossa \u00e8 convenzionalmente collegata. Questa porta permette la misura di correnti (fino a 200mA), la tensione (V), e resistenza (\u03a9).</p>"},{"location":"corso/08_il_multimetro/#misura-della-resistenza-con-un-multimetro","title":"Misura della resistenza con un multimetro","text":"<p>Le normali resistenze hanno codici di colore su di loro. Ci sono un sacco di calcolatori online che sono facili da usare. Tuttavia, se mai vi trovate senza accesso a internet, un multimetro \u00e8 molto utile per misurare la resistenza. \u200b Scegliere una resistenza casuale e impostare il multimetro per l'impostazione 20k\u03a9. Quindi tenere le sonde sui reoferi del resistore. </p> <p>Ricordarsi di portare il selettore della manopola su un valore di resistenza. Se ad esempio selezioniamo 2k\u03a9, questo significa che possiamo misurare resistenze di valore non pi\u00f9 grande di 2k\u03a9. Se ad esempio la resistenza sar\u00e0 da 1k\u03a9 nominale, potr\u00e0 succedere di leggere il valore di 0.97 (ogni resistenza ha una sua tolleranza e non sar\u00e0 quasi mai precisa). Se invece metteremo una resistenza ad esempio da 10k\u03a9, il multimetro dar\u00e0 un valore di 1 che significa che abbiamo superato il fondo scala (in questo caso 2k\u03a9). Dovremo allora mettere il cursore su un valore pi\u00f9 alto.</p>"},{"location":"corso/08_il_multimetro/#misura-della-continuita","title":"Misura della continuit\u00e0","text":"<p>Un caso particolare della misura della resistenza \u00e8 quello della continuit\u00e0. Con questo termine si intende dire: verificare che tra due punti ci sia una resistenza di 0\u03a9. Detto in altri termini, con questa misura si vede se tra due punti del circuito ci sia un cortocircuito. Il Selettore deve essere messo nel simbolo del diodo come visto in figura.</p> <p></p> <p>Se c'\u00e8 continuit\u00e0 (o cortocircuito), il multimetro ci avverte con un suono continu\u00f2.</p>"},{"location":"corso/08_il_multimetro/#misura-della-tensione","title":"Misura della tensione","text":""},{"location":"corso/08_il_multimetro/#misura-della-corrente-in-continua","title":"Misura della corrente in continua","text":"<p>Supponiamo di voler misurare la tensione di una batteria da 1.5Volt (valore nominale). Dobbiamo mettere i puntali delle sonde ai capi della batteria e il selettore della manopola su 2V (fondoscala maggiore del valore nominale della batteria). Nel nostro caso, dal momento che la batteria \u00e8 nuova, si legge un valore di 1,629V.</p> <p></p>"},{"location":"corso/08_il_multimetro/#misura-della-corrente-in-alternata","title":"Misura della corrente in alternata","text":"<p>In questo caso possiamo misurare valore di tensione in alternata, ad esempio la tensione che abbiamo nelle prese di casa (220V).</p> <p></p> <p>Vi consiglio di non farlo a meno che non siate dei provetti elettricisti in quanto la tensione 220V \u00e8 pericolosa (letale). </p>"},{"location":"corso/08_il_multimetro/#misura-della-corrente","title":"Misura della corrente","text":"<p>Per fare una misura della corrente bisogna mettersi in serie con il circuito da misurare. In pratica, dovremmo interrompere il circuito ed inserirci con le nostre sonde nel circuito interrotto in modo che la corrente entri in una sonda, passi all'interno del multimetro e poi esca dall'altra sonda in modo da rientrare nel circuito. Il selettore dovr\u00e0 essere ruotato in modo da selezionare un fondo scala appropriato (da 20uA a 10A).</p> <p></p> <p>NOTA: Nel caso di 10A, bisogna cambiare la posizione della sonda rossa nel punto di ingresso pi\u00f9 a sinistra (vedi figura in cima al documento).</p>"},{"location":"corso/09_corrente_tensione_circuito/","title":"Corrente, Tensione e Circuito Elettrico","text":"<p>Immagina l\u2019elettricit\u00e0 come un \u201ctraffico\u201d di minuscole particelle cariche, gli elettroni, che possono muoversi dentro certi materiali. Quando questo movimento \u00e8 organizzato e continuo parliamo di corrente elettrica. In altri termini, la corrente elettrica \u00e8 la quantit\u00e0 di carica (elettroni) che passa in un circuito nell\u2019unit\u00e0 di tempo. L\u2019unit\u00e0 di misura \u00e8 l\u2019ampere (A) e corrisponde a un coulomb al secondo.   ### Relazione tra corrente e carica</p> <p>La corrente elettrica ( I ) \u00e8 definita come la variazione della carica ( Q ) nel tempo: </p> <p> </p> <p>Per far muovere quelle cariche serve una spinta. Quella spinta si chiama tensione o differenza di potenziale ed \u00e8 l\u2019energia disponibile per ogni unit\u00e0 di carica affinch\u00e9 compia un percorso. Si misura in volt (V) e puoi pensarla come la pressione che mette in moto l\u2019acqua. Se la tensione \u00e8 alta, gli elettroni hanno pi\u00f9 energia per attraversare un componente; se \u00e8 bassa, la spinta \u00e8 modesta. In termini fisici, 1 V = 1 J/C: un volt \u00e8 un joule di energia per coulomb di carica. </p> <p>Non \u00e8 diverso dall\u2019idea di una portata d\u2019acqua in un tubo: pi\u00f9 elettroni scorrono in un secondo, maggiore \u00e8 la corrente.  </p> <p>Analogia con il flusso di acqua in un tubo. </p> <p>Tra la spinta e il flusso c\u2019\u00e8 di mezzo la \u201cstrada\u201d che le cariche devono percorrere. I materiali non sono tutti uguali: alcuni lasciano passare gli elettroni con facilit\u00e0 (conduttori), altri oppongono resistenza (isolanti o, pi\u00f9 spesso, resistenze controllate). La relazione pi\u00f9 celebre che lega questi elementi \u00e8 la legge di Ohm: <code>V = I \u00b7 R</code>.  A parit\u00e0 di tensione, una resistenza grande lascia passare poca corrente; a parit\u00e0 di resistenza, pi\u00f9 volt significano pi\u00f9 ampere. </p> <p>Un circuito elettrico \u00e8 il percorso chiuso che permette alla corrente di andare dal polo positivo a quello negativo di una sorgente. \u201cChiuso\u201d \u00e8 la parola chiave: senza un anello completo, le cariche non possono fluire in modo continuo. La sorgente (una batteria, un alimentatore) stabilisce la differenza di potenziale; i conduttori offrono il cammino; i componenti lungo la strada \u2014 lampadine, resistenze, sensori, motori \u2014 trasformano l\u2019energia elettrica in altre forme utili. Se apri l\u2019anello con un interruttore, interrompi il flusso; se lo richiudi, la corrente riprende immediatamente a scorrere. In quest\u2019ottica, un corto circuito \u00e8 un percorso troppo facile e quasi senza resistenza tra i poli: la corrente diventa enorme con rischi di surriscaldamento e danni.</p> <p>Nella pratica quotidiana incontriamo due modi diversi di \u201cerogare\u201d la tensione. La corrente continua (DC), tipica delle batterie e dei microcontrollori come l\u2019ESP32, mantiene costanti polarit\u00e0 e valore, al netto di piccole ondulazioni. La corrente alternata (AC), tipica della rete domestica, fa oscillare periodicamente la tensione e, di conseguenza, la direzione del flusso medio della corrente.  </p> <p>Ci sono strumenti che permettono di verificare e misurare i valori di corrente (amperometro), tensione (Voltmetro) e Resistenza (Ohmmetro). In seguito vedremo il funzionamento del multimetro che in un singolo dispositivo permette di fare le tre misure dette sopra.</p>"},{"location":"corso/09_corrente_tensione_circuito/#esperimenti","title":"Esperimenti","text":""},{"location":"corso/09_corrente_tensione_circuito/#1-output-su-un-gpio","title":"1 - Output su un GPIO","text":"<p>Si scriva un programma in modo da alternare uno zero (LOW) e un uno (HIGH) su un pin GPIO (ad esempio GPIO4). Si metta una pausa di almento un paio di secondi tra una alternanza e l'altra. Si verifichi quindi con il multimetro, messo in modalit\u00e0 di lettura della tensione continua, che il valore letto dallo strumento sia 0.0 e 3.3Volt a seconda di quello che scrivere su GPIO4. I due puntali (rosso e nero) devo essere collegati sul pin di massa (GND) e GPIO4 del ESP32.  In figura con il simbolo V si intende il multimentro messo in modalit\u00e0 voltometro.</p>"},{"location":"corso/09_corrente_tensione_circuito/#2-collegamento-di-una-resistenza","title":"2 - collegamento di una resistenza","text":"<p>Si esegua il circuito come indicato in figura:    Ora il multimetro \u00e8 usato in modalit\u00e0 Amperometro (lettura di corrente che scorre nel conduttore).    Con lo stesso programma di prima dovresto vedere corrente 0 ampere (A) quando sul pin GPIO4 pilotate uno 0, e un valore con GPIO4 a 1.   Con la resistenza da 220ohm, verificate che la corrente letta dallo strumento sia uguale a quella ricavata dalla formula.</p> <p>ripetere la stessa misura con R=1kohm e R=10kohm.   Controllare sempre con la formula V=R*I.  </p>"},{"location":"corso/10_sensori/","title":"Sensori e ESP32","text":"<p>In questo capitolo andremo semplicemente a definire gli oggetti di base tramite i quali costruire i nostri progetti hardware,  governati da un ESP32 e controllati tramite codice MicroPython.</p> <p>Introduciamoli!</p>"},{"location":"corso/10_sensori/#breadboard","title":"BreadBoard","text":"<p>Una breadboard \u00e8 una basetta di prototipazione per realizzare esperimenti e prototipi senza il bisogno di eseguire saldature: permette di collegare componenti elettronici e fili inserendoli a pressione nella basetta per montare, testare e modificare circuiti in pochi secondi. \u00c8 perfetta per attivit\u00e0 didattiche, perch\u00e9 gli studenti possono sperimentare senza rischiare di rovinare i componenti. E senza rischiare di bruciarsi le dita usando il saldatore a stagno necessario per saldare i fili. Nella foto seguente si vede una classica basetta breadboard con una resistenza e un led inseriti nella basetta.</p> <p></p>"},{"location":"corso/10_sensori/#come-e-fatta-e-come-funziona","title":"Come \u00e8 fatta e come funziona","text":"<p>La figura seguente ci aiuta a capire come \u00e8 fatta una breadboard. Questa parte del documento lo dovete ASSOLUTAMENTE CAPIRE BENE per evitare di bruciare \ud83d\udd25 il vostro circuito  (e quindi anche i componenti che vi fornisce la scuola \ud83e\udd2c).     - Blocchi centrali (matrice): quelli con le linee verdi. Ci sono due sezioni di fori separate da una fessura. Come indicato dall'immagine i fori segnati con la linea verde sono collegati fra di loro. </p> <p>ATTENZIONE: i fori della parte superiore non sono collegati con i fori della parte inferiore anche se appartengono alla stessa colonna.</p> <ul> <li>Binari di alimentazione (rail): due coppie di linee laterali contrassegnate (+ rosso, \u2013 blu/nero) che corrono in orizzontale lungo la breadboard. Queste linee sono utilizzate per mettere le alimentazioni (ad. esempio 5V o 3.3V) e il segnale di massa o ground (anche indicato come GND). Capirete qualcosa in pi\u00f9 quando daremo concetti elementari di circuiti elettrici. Per evitare problemi usate la convenzione di mettere le alimentazioni sulle linee rosse e il ground sulla linea nera/blu. <p>ATTENZIONE: tutti i fori indicati in rosso sono collegati tra loro, cos\u00ec come tutti i fori indicato in blu. Ma la parte superiore non \u00e8 collegata con la parte inferiore. La stessa figura vi fa vedere (nella parte a destra) come effettivamente sono eseguiti i collegamenti tramite contatti metallici che, come ovviamente sapete, sono materiali conduttivi.  </p> </li> </ul>"},{"location":"corso/10_sensori/#resistenze","title":"Resistenze","text":"<p>Una resistenza \u00e8 un componente elettrico passivo che si oppone al passaggio di corrente elettrica. Quanto forte sia la sua capacit\u00e0 di opposizione  dipende dalla quantit\u00e0 di corrente che passa e dalla sua... resistenza. </p> <p></p> <p>La capacit\u00e0 di opposizione si misura in Ohm e il rapporto fra le grandezze in gioco \u00e8 descritto dalla Prima legge di Ohm:</p> <p><code>V = R * I</code></p> <p>dove:</p> <ul> <li><code>V</code> rappresenta la differenza di potenziale fra le due estremit\u00e0 della resistenza e si misura in <code>Volt (V)</code></li> <li><code>R</code> rappresenta la resistenza del componente elettrico al passaggio di corrente e si misura in <code>Ohm (\u03a9)</code></li> <li><code>I</code> rappresenta la quantit\u00e0 di corrente in attraversamento e si misura in <code>Ampere (A)</code></li> </ul> <p>I colori delle resistenze</p> <p>Come avrete notato, le resistenze hanno dei cerchi colorati che le decorano, che servono a capire con quale resistenza abbiamo a che fare.</p> <p>Per capire come funzionano... provare a ragionare sull'immagine seguente:</p> <p></p>"},{"location":"corso/10_sensori/#transistor","title":"Transistor","text":"<p>Un transistor \u00e8 un dispositivo elettronico in grado di funzionare da interruttore o da amplificatore.  Come si intuisce dalle figure sotto, un transistor \u00e8 un oggetto elettronico con tre collegamenti verso l\u2019esterno:</p> <ol> <li>Base (B): da dove solitamente arrivano i segnali di comando</li> <li>Emettitore (E): da dove solitamente escono i segnali elaborati dal transistor</li> <li>Collettore (C): da dove solitamente arriva la corrente</li> </ol> <p></p> <p>Neanche a dirlo, nel nostro kit sono disponibili ben due tipologie di transistor:</p> <ul> <li>transistor NPN, o transistor negativo</li> <li>transistor PNP, o transistor positivo</li> </ul> <p>La differenza fondamentale fra i due tipi sta nel fatto che nel transistor NPN la corrente positiva va collegata al collettore C, ottenendo in uscita una corrente negativa, mentre nel transistor PNP la corrente positiva va collegata all\u2019emettitore E, ottenendo in uscita una corrente positiva.</p> <p>Quando serviranno in alcuni dei progetti che faremo... ci ritorneremo!</p> <p> </p>"},{"location":"corso/11_1_Il%20LED%20teoria%20e%20applicazioni/","title":"Lezione sul LED: teoria e applicazioni con ESP32","text":""},{"location":"corso/11_1_Il%20LED%20teoria%20e%20applicazioni/#introduzione","title":"Introduzione","text":"<p>In questa lezione verr\u00e0 studiato il LED (Light Emitting Diode), uno dei componenti elettronici pi\u00f9 semplici ma anche pi\u00f9 utilizzati. La lezione \u00e8 divisa in due parti: 1. Parte teorica: funzionamento fisico ed elettrico del LED 2. Parte pratica: utilizzo del LED con ESP32 e programmazione in MicroPython  </p>"},{"location":"corso/11_1_Il%20LED%20teoria%20e%20applicazioni/#1-parte-teorica","title":"1. Parte teorica","text":""},{"location":"corso/11_1_Il%20LED%20teoria%20e%20applicazioni/#11-i-semiconduttori","title":"1.1 I Semiconduttori","text":"<p>I semiconduttori, nella scienza e tecnologia dei materiali, sono materiali che hanno resistivit\u00e0 intermedia tra i metalli e gli isolanti. Sono esempi di semiconduttori il silicio e il germanio, l'arseniuro di gallio (GaAs) e il carburo di silicio (SiC).</p> <p>Essi sono alla base di tutti i principali dispositivi elettronici e microelettronici a stato solido quali transistor, diodi e diodi a emissione luminosa (LED). </p>"},{"location":"corso/11_1_Il%20LED%20teoria%20e%20applicazioni/#il-semiconduttore-e-la-sua-conducibilita","title":"Il semiconduttore e la sua conducibilit\u00e0","text":"<p>Un semiconduttore \u00e8 un materiale la cui conducibilit\u00e0 elettrica \u00e8 intermedia tra quella di un conduttore (come il rame la cui resistenza si approssima a $1.68 \\times 10^{-8}$ ohm) e quella di un isolante (come la plastica con resistivit\u00e0 $10^9$ ohm). La sua conducibilit\u00e0 dipende dalla struttura energetica degli elettroni all\u2019interno del materiale.</p>"},{"location":"corso/11_1_Il%20LED%20teoria%20e%20applicazioni/#bande-energetiche-valenza-e-conduzione","title":"Bande energetiche: valenza e conduzione","text":"<p>Negli atomi di un solido, gli elettroni possono occupare solo determinati livelli energetici, organizzati in bande: </p> <ul> <li> <p>Banda di valenza   \u00c8 la banda energetica occupata dagli elettroni legati agli atomi responsabili dei legami chimici. In questa banda gli elettroni non si possono muovere liberamente, quindi non contribuiscono alla corrente elettrica.</p> </li> <li> <p>Banda di conduzione   \u00c8 una banda energetica superiore, piu alta rispetto a quella di conduzione dove gli elettroni:  </p> </li> <li>non sono pi\u00f9 legati ad un atomo specifico;  </li> <li>possono muoversi liberamente nel materiale;  </li> <li>quindi trasportano corrente elettrica.  </li> </ul> <p>Tra le due bande esiste una zona proibita detta gap energetico (band gap). - se il gap \u00e8 piccolo -&gt; l'elettrone pu\u00f2 saltare facilmente nella banda di conduzione; - se il gap \u00e8 grande -&gt; \u00e8 molto difficile realizzare il salto.  </p>"},{"location":"corso/11_1_Il%20LED%20teoria%20e%20applicazioni/#confronto-tra-materiali-metalli-semiconduttori-isolanti","title":"Confronto tra materiali, metalli, semiconduttori, isolanti","text":"<p>LA loro classificazione dipende tutto da come sono queste bande:  </p> <ul> <li> <p>Conduttori o Metalli   La banda di valenza e quella di conduzione si sovrappongono \u2192 gli elettroni sono liberi di muoversi.</p> </li> <li> <p>Isolanti   Il gap energetico \u00e8 molto grande \u2192 gli elettroni non riescono a raggiungere la banda di conduzione. Non c'\u00e8 passaggio di corrente. </p> </li> <li> <p>Semiconduttori   Il gap energetico \u00e8 piccolo ma non nullo \u2192 alcuni elettroni possono passare alla banda di conduzione se ricevono energia (calore, luce, campo elettrico).</p> </li> </ul>"},{"location":"corso/11_1_Il%20LED%20teoria%20e%20applicazioni/#_1","title":"Led teoria e esercizi","text":""},{"location":"corso/11_1_Il%20LED%20teoria%20e%20applicazioni/#il-caso-del-silicio","title":"Il caso del silicio","text":"<p>Il silicio (Si) \u00e8 il semiconduttore pi\u00f9 utilizzato in elettronica.</p> <p>Caratteristiche principali: - ha 4 elettroni di valenza - forma una struttura cristallina molto stabile - a temperatura ambiente ha pochi elettroni liberi  </p> <p> </p> <p>Nel silicio puro: - la banda di valenza \u00e8 quasi completamente occupata - la banda di conduzione \u00e8 quasi vuota  </p> <p>A temperatura ambiente, una piccola quantit\u00e0 di elettroni: - riesce a superare il gap energetico - passa nella banda di conduzione - lascia una lacuna nella banda di valenza  </p> <p>Quando un elettrone passa alla banda di conduzione: - l\u2019elettrone libero contribuisce alla corrente - la lacuna si comporta come una carica positiva mobile  </p> <p>Nel semiconduttore la corrente \u00e8 quindi dovuta a: - elettroni nella banda di conduzione - lacune nella banda di valenza  </p>"},{"location":"corso/11_1_Il%20LED%20teoria%20e%20applicazioni/#perche-il-silicio-e-cosi-importante","title":"Perch\u00e9 il silicio \u00e8 cos\u00ec importante","text":"<p>Il silicio \u00e8 ideale perch\u00e9:  </p> <ul> <li>pu\u00f2 essere facilmente drogato per controllarne la conducibilit\u00e0  </li> <li>\u00e8 abbondante e stabile in natura  </li> </ul> <p>Queste propriet\u00e0 rendono il silicio come l'elemento principale nella realizzazione di dispositivi largamente utilizzati in elettronica come: - diodi - LED - transistor - microprocessori  </p>"},{"location":"corso/11_1_Il%20LED%20teoria%20e%20applicazioni/#il-drogaggio","title":"Il drogaggio","text":"<p>Il drogaggio consiste nell\u2019aggiungere piccolissime quantit\u00e0 di atomi \u201cestranei\u201d all'interno del reticolo cristallino del silicio puro per modificare la sua conducibilit\u00e0 elettrica. Importante capire che, con il drogaggio non si cambia il materiale, ma solo il comportamento elettrico del silicio. Vediamo cosa significa drogare il silicio e quali sono i suoi effetti.  </p>"},{"location":"corso/11_1_Il%20LED%20teoria%20e%20applicazioni/#11-drogaggio-di-tipo-n-e-di-tipo-p","title":"1.1 Drogaggio di tipo N e di tipo P","text":""},{"location":"corso/11_1_Il%20LED%20teoria%20e%20applicazioni/#drogaggio-di-tipo-n","title":"Drogaggio di tipo N","text":"<p>Nel reticolo cristallino del silicio, si aggiungono atomi con 5 elettroni di valenza (gruppo V): - Fosforo (P) - Arsenico (As)  </p> <p>In questo modo succede che: - 4 elettroni fanno i legami - 1 elettrone resta libero  </p> <p>L'elettrone che rimane libero pu\u00f2 muoversi facilmente e movimento di elettroni significa corrente elettrica.</p> <p>Questo tipo di silicio si dice drogato N in quanto nella struttura cristallina risulta presente un'eccedenza di cariche negative (N) che si possono facilmente muovere. E quindi il silicio, che in condizioni non drogate \u00e8 un elemento semi-conduttore, in oppurtune condizioni che vedremo di seguito, pu\u00f2 diventare conduttore.</p>"},{"location":"corso/11_1_Il%20LED%20teoria%20e%20applicazioni/#drogaggio-di-tipo-p","title":"Drogaggio di tipo P","text":"<p>Si aggiungono atomi con 3 elettroni di valenza (gruppo III):  - Boro (B) - Alluminio (Al)  </p> <p>Con questo tipo di drogaggio, ci sono tre elettroni che il Boro, ad esempio, mette a disposizione per i collegamenti di valenza con gli atomi di silicio. Di conseguenza, manca un elettrone per completare i legami del reticolo cristallino.</p> <p>Si crea, in pratica, una lacuna (buco). Le lacune si comportano come cariche positive. Questo tipo di silicio si dice drogato P in quanto nella struttura cristallina risulta presente un'eccedenza di cariche positive (P) che gli elettroni possono facilmente occupare.  Anche in questo caso, il silicio, che in condizioni non drogate \u00e8 un elemento semi-conduttore, in oppurtune condizioni che vedremo di seguito, pu\u00f2 diventare conduttore.</p>"},{"location":"corso/11_1_Il%20LED%20teoria%20e%20applicazioni/#12-la-giunzione-pn","title":"1.2 La giunzione PN","text":"<p>Una giunzione a semiconduttore, detta anche giunzione PN, \u00e8 l\u2019unione di due materiali semiconduttori drogati in modo diverso:</p> <ul> <li>Regione P: contiene un eccesso di lacune (cariche positive)  </li> <li>Regione N: contiene un eccesso di elettroni (cariche negative)  </li> </ul> <p> </p> <p>Quando le due regioni vengono messe a contatto, una parte delle lacune in eccesso presenti nello strato p inizieranno a migrare verso lo strato n. Viceversa, una parte degli elettroni in eccesso nello strato n inizieranno a migrare verso lo strato p. In realt\u00e0, il moto delle lacune \u00e8 solo apparente: essendo esse, le lacune, niente altro che \"assenza di elettroni\", non sono le lacune che si muovono ma le cariche elettriche che le vanno ad occupare.  Questo movimento per\u00f2 dura poco e, per un discorso di potenziali elettrici che si formano, si interrompe il flusso di elettroni e quindi di corrente elettrica.  </p> <p>Quindi:  - elettroni e lacune tendono a ricombinarsi - si crea una zona di svuotamento (depletion zone) - nasce una barriera di potenziale, - si raggiunge un equilibrio che impedisce il passaggio  di corrente  </p> <p> </p>"},{"location":"corso/11_1_Il%20LED%20teoria%20e%20applicazioni/#polarizzazione-della-giunzione-a-circuito-chiuso","title":"Polarizzazione della giunzione a circuito chiuso","text":"<p>Ora analizzeremo il comportamento della giunzione p-n a circuito chiuso, ossia il funzionamento della giunzione p nel momento in cui viene applicato un campo elettrico esterno. Quindi collegheremo gli estremi della giunzione ad una batteria.  </p> <ul> <li>Polarizzazione diretta:   Applicando una tensione che riduce la barriera di potenziale, la corrente pu\u00f2 fluire attraverso la giunzione. Quindi, colleghiamo il polo positivo della batteria al contatto metallico dell\u2019anodo della zona p e il polo negativo al contatto metallico del catodo della zona n come indicato in figura. </li> </ul> <p>Quando si applica una tensione sufficiente (almeno maggiore di 0,7V) alla giunzione PN, l'effetto \u00e8 quello di vincere la condizione di equilibrio raggiunta (barriera di svuotamento), nuovi elettroni vengono forniti al silicio di tipo N, i quali riescono a superare la barriera di equilibrio per procedere nella sezione P. Si crea quindi un flusso di corrente.  </p> <ul> <li>Polarizzazione inversa:   Nella polarizzazione inversa, applicando una tensione opposta, la barriera aumenta e la corrente non passa.  </li> </ul>"},{"location":"corso/11_1_Il%20LED%20teoria%20e%20applicazioni/#perche-e-importante","title":"Perch\u00e9 \u00e8 importante","text":"<p>La giunzione PN pu\u00f2 funzionare come un interruttore: - applicando ai suoi capi una tensione opportuna, la corrente circola e il circuito \u00e8 chiuso; - togliendo questa tensione, la giunzione PN funziona come un interruttore aperto, quindi la corrente non circola.  </p>"},{"location":"corso/11_1_Il%20LED%20teoria%20e%20applicazioni/#13-il-led","title":"1.3 Il LED","text":"<p>Il LED \u00e8 un tipo particolare di giunzione PN in cui la corrente che attraversa la giunzione produce luce grazie alla ricombinazione di elettroni e lacune. Il LED (Light Emitting Diode) \u00e8 detto anche diodo a emissione luminosa, cio\u00e8 un componente elettronico semiconduttore che: - lascia passare la corrente in un solo verso - emette luce quando viene attraversato da corrente elettrica</p>"},{"location":"corso/11_1_Il%20LED%20teoria%20e%20applicazioni/#perche-emette-luce","title":"Perch\u00e8 emette luce","text":"<p>Il principio di funzionamento \u00e8 sempre lo stesso del diodo (giunzione PN): riduzione della barriera di potenziale e passaggio di corrente. La differenza sta in come viene rilasciata l\u2019energia. nel momento in cui un elettrone passa da un livello energetico all'altro durante il suo movimento nel reticolo cristallino.   </p> <p>Quando il LED \u00e8 polarizzato direttamente: - gli elettroni del lato N attraversano la giunzione - le lacune del lato P attraversano la giunzione - avviene la ricombinazione elettrone\u2013lacuna  </p> <p>e fin qui il comportamento \u00e8 quello di un diodo normale.  </p> <p>Durante la ricombinazione l\u2019elettrone passa da un livello energetico pi\u00f9 alto (banda di conduzione) a uno pi\u00f9 basso (banda di valenza). La differenza di energia non viene dissipata come calore ma viene emessa sotto forma di fotone (luce).  </p> <p>Questa emissione si chiama elettroluminescenza. Il colore della luce emessa dipende dal materiale semiconduttore e dal suo gap energetico.  </p>"},{"location":"corso/11_1_Il%20LED%20teoria%20e%20applicazioni/#polarizzazione-del-led","title":"Polarizzazione del LED","text":"<p>Il LED ha due terminali: - Anodo (+) \u2192 gamba pi\u00f9 lunga - Catodo (\u2212) \u2192 gamba pi\u00f9 corta  Per funzionare correttamente: - l\u2019anodo deve essere collegato al positivo - il catodo al negativo (GND)  </p> <p>Se collegato al contrario: - il LED non conduce - il LED non si accende  </p>"},{"location":"corso/11_1_Il%20LED%20teoria%20e%20applicazioni/#tensione-diretta-e-corrente","title":"Tensione diretta e corrente","text":"<p>Il LED non deve essere collegato direttamente a una sorgente di tensione. Valori tipici della tensione e corrente da fornire ai capi di un LED: - Tensione diretta (Vf):   - Rosso: ~1.8\u20132.0 V   - Verde: ~2.0\u20132.2 V   - Blu / Bianco: ~3.0\u20133.3 V - Corrente nominale:   - 5\u201320 mA Il LED non \u00e8 una resistenza per cui se viene collegato direttamente a una tensione esterna, il valore di corrente che vi passerebbe \u00e8 sicuramente molto maggiore di quella propria di funzionamento e si danneggerebbe. (in base alle legge di ohm V=R*I).  </p>"},{"location":"corso/11_1_Il%20LED%20teoria%20e%20applicazioni/#resistenza-di-limitazione","title":"Resistenza di limitazione","text":"<p>Per proteggere il LED si utilizza una resistenza in serie. Formula di calcolo: R = (V_alimentazione \u2212 V_LED) / I_LED  </p> <p>Esempio: - ESP32: 3.3 V - LED rosso: 2.0 V - Corrente: 10 mA  </p> <p>R = (3.3 \u2212 2.0) / 0.01 = 130 \u03a9 Valori commerciali consigliati: - 150 \u03a9 - 220 \u03a9  </p>"},{"location":"corso/11_1_Il%20LED%20teoria%20e%20applicazioni/#2-parte-pratica-led-con-esp32-e-micropython","title":"2. Parte pratica \u2013 LED con ESP32 e MicroPython","text":""},{"location":"corso/11_1_Il%20LED%20teoria%20e%20applicazioni/#21-obiettivi-della-parte-pratica","title":"2.1 Obiettivi della parte pratica","text":"<ul> <li>Collegare correttamente un LED a un ESP32  </li> <li>Usare un GPIO come uscita digitale  </li> <li>Controllare il LED tramite software  </li> <li>Comprendere il legame tra codice e hardware  </li> </ul>"},{"location":"corso/11_1_Il%20LED%20teoria%20e%20applicazioni/#22-materiale-necessario","title":"2.2 Materiale necessario","text":"<ul> <li>ESP32</li> <li>LED</li> <li>Resistenza da 220 \u03a9</li> <li>Breadboard</li> <li>Cavetti jumper</li> <li>PC con MicroPython installato sull\u2019ESP32</li> </ul>"},{"location":"corso/11_1_Il%20LED%20teoria%20e%20applicazioni/#23-collegamento-hardware","title":"2.3 Collegamento hardware","text":"<p>Schema logico di collegamento: </p> <p>Esempio pratico: - GPIO utilizzato: GPIO 2 - Collegamento a GND per il catodo  </p>"},{"location":"corso/11_1_Il%20LED%20teoria%20e%20applicazioni/#24-primo-programma-led-lampeggiante","title":"2.4 Primo programma: LED lampeggiante","text":"<pre><code>from machine import Pin\nimport time\n\nled = Pin(2, Pin.OUT)\n\nwhile True:\n    led.value(1)   # Accende il LED\n    time.sleep(1)\n    led.value(0)   # Spegne il LED\n    time.sleep(1)\n</code></pre>"},{"location":"corso/11_1_Il%20LED%20teoria%20e%20applicazioni/#25-altre-esercitazioni","title":"2.5 Altre esercitazioni","text":"<p>Creare un circuito con 3 led (di colore Rosso, Gialla e Verde). I led devono essere comandati dal vostro programma in modo indipendente, quindi dovrete collegare ogni circuito del led con 3 diversi GPIO.  </p> <p>Quindi realizzate 3 programmi diversi in cui: - si accende e spegne tutti i led in contemporanea; - si accende un led alla volta in progressione (1 acceso e gli altri spenti)  - si simulare il comportamento di un semaforo stradale.  </p>"},{"location":"corso/11_1_Il%20LED%20teoria%20e%20applicazioni/#26-codice-morse","title":"2.6 Codice MORSE","text":"<p>Realizzare un programma in micropython e ESP32 per trasmettere un messaggio in codice Morse.  </p> <p>Materiale: - ESP32 - 1 LED - 1 resistenza (220 ohm) - breadboard e cavetti  </p> <p>Il programma deve:  </p> <ul> <li>Definire una stringa di testo (solo lettere e spazi, es. \"SOS AIUTO\"). La strnga deve essere chiesta in input.  </li> <li>Convertire ogni lettera nel codice Morse corrispondente.</li> <li>Trasmettere il messaggio usando il LED secondo le regole:  </li> <li>Punto (\u00b7) \u2192 LED acceso per 0,2 s  </li> <li>Linea (\u2013) \u2192 LED acceso per 0,6 s  </li> <li>Pausa tra simboli \u2192 0,2 s  </li> <li>Pausa tra lettere \u2192 0,6 s  </li> <li>Pausa tra parole \u2192 1,4 s  </li> <li>Ripetere il messaggio in ciclo continuo.  </li> </ul> <p>Usare un dizionario per associare ogni lettera al suo codice Morse.  </p>"},{"location":"corso/11_1_Il%20LED%20teoria%20e%20applicazioni/#27-binario","title":"2.7 Binario","text":"<p>Realizzare un programma che inserito in input un numero rappresenti il numero in binario. Si consideri un numero compreso tra 0 e 15. </p> <p>Si usino 4 led (bit3, bit2, bit1, bit0) che si accendo in corrispondenza di un 1 e si spengono in corrispondenza di uno 0.  Ad esempio: 10 --&gt; 1010 (ON-OFF-ON-OFF)  </p> <p>Se il numero \u00e8 maggiore di 15 o minore di 0, i 4 led lampeggiano contemporaneamente per 4 secondi.  </p>"},{"location":"corso/11_led_ledbar/","title":"Led(s)","text":"<p>Un LED \u00e8 un componente elettronico che funziona solo quando la corrente scorre nel verso giusto. Tipicamente ha due poli: il polo positivo nel pin pi\u00f9 lungo (catodo) e il polo negativo nel pin pi\u00f9 corto (anodo).</p> <p></p> <p>I led lavorano ad una corrente di attraversamento compresa fra 1.9V e 3.3V. Se la corrente supera questo voltaggio, il LED si dannegger\u00e0 e magari... prender\u00e0 fuoco. </p>"},{"location":"corso/11_led_ledbar/#led-integrato","title":"LED Integrato","text":"<p>Come abbiamo (probabilmente) gi\u00e0 anticipato, la nostra MCU (il microcontrollore, l'ESP32) contiene un led integrato in essa e collegato direttamente al Pin fisico numero 5.</p> <p>Per farlo funzionare sar\u00e0 necessario semplicemente eseguire un codice del genere:</p> Led integrato lampeggiante<pre><code>from machine import Pin\nimport time\n\n# Il pin 5 \u00e8 quello del LED programmabile\n# Se collegate un LED fisico ad un GPIO, modificate il numero qui sotto!\nled = Pin(5, Pin.OUT)\nled.off()\n\nwhile True:\n    led.on()\n    print(\"LED Acceso\")\n    time.sleep(1)\n\n    led.off()\n    print(\"LED Spento\")\n    time.sleep(1)\n</code></pre> <p>Non c'\u00e8 molto altro da aggiungere </p>"},{"location":"corso/11_led_ledbar/#led-fisico","title":"LED Fisico","text":"<p>In questo progetto dobbiamo costruire un circuito per collegare un led all'ESP32. Il circuito dovr\u00e0 realizzare uno schema tipo il seguente:</p> <p></p> <p>A seconda del PIN scelto per il collegamento fisico del LED, modificate il codice dell'esempio precedente per far accendere il led che avete appena collegato.</p>"},{"location":"corso/11_led_ledbar/#led-bar","title":"LED Bar","text":"<p>La barra dei LED \u00e8 un semplice componente in cui sono integrati ben 10 LED!!! Il collegamento fisico al microcontrollore \u00e8 una semplice iterazione del circuito del LED:</p> <p></p> <p>Adesso tramite codice andiamo a fornire un comportamento al nostro progetto: Facciamo in modo che ogni secondo la barra si riempa sempre pi\u00f9 e poi inizi a svuotarsi. Ecco il codice:</p> ledbar che si carica e scarica<pre><code>from machine import Pin\nimport time\n\n# I 10 pin, in ordine di connessione alla ledbar\npins=[22,21,19,23,18,17,16,4,2,15]\n\nacceso = True\nwhile True:\n    for p in pins:\n        led = Pin( p, Pin.OUT)\n        led.value( acceso )\n        time.sleep_ms(500)\n\n    # rovescia l'ordine dei pin\n    pins.reverse()\n\n    # inverti vero/falso\n    acceso = not acceso\n</code></pre>"},{"location":"corso/11_led_ledbar/#esercizi","title":"Esercizi","text":"<p>Dal vivo o con il simulatore!</p> <p>Ognuno dei seguenti esercizi pu\u00f2 essere svolto indifferentemente dal vivo, ovvero con ESP32 e sensori reali, oppure con il simulatore wokwi (ad esempio come compiti per casa)!!!</p> <p></p> <p>Luci della Polizia!</p> <p>Due led, uno rosso e uno blu. Si accendono alternativamente ogni decimo di secondo (regolate il tempo necessario, se un decimo \u00e8 poco o troppo!) Quando la luce rossa si accende, la blu si spegne e viceversa</p> <p></p> <p>Semaforo</p> <p>Tre led: verde, giallo, rosso. Implementazione di un semaforo. All'inizio la luce gialla lampeggia (accesa.. spenta.. accesa.. spenta). Poi tutto un tratto (scegliete voi quanto) parte il semaforo! Prima la luce rossa per due secondi, poi la luce verde per 4 secondi, la luce gialla per 1 secondo. Poi rosso e si ricomincia!</p> <p></p> <p>LED...Bar</p> <p>Una ledbar collegata all'esp32. La barra inizia da spenta e poi inizia il caricamento accendendo prima un led, poi due, poi tre... e cos\u00ec via ogni secondo. Quando la barra \u00e8 piena rimane accesa per due secondi, poi si spegne completamente per un secondo, poi si riaccende completamente per due secondi. A questo punto inizia a scaricarsi. Ogni secondo si spegne un led fino a che la barra non sia completamente spenta. A questo punto il programma termina.</p> <p> </p>"},{"location":"corso/12_buttons/","title":"Buttons","text":"<p>In questo capitolo andremo a provare alcuni esperimenti in cui costruiremo progetti hardware basati sui pulsanti e i led, governati da un ESP32 e controllati tramite codice MicroPython.</p> <p>I pulsanti hardware hanno due caratteristiche fisiche che vanno sempre considerate quando se ne inserisce uno in un circuito:</p> <ul> <li> <p>floating inputs: significa che quei segnali non hanno un valore ben definito (0 o 1) ma sono variabili (floating). In questo modo l'ESP32 non sa se il valore di tensione che legge sui suoi pin sia 1 (3.3V) oppure 0 (0V). Questo problema si pu\u00f2 risolvere con una resistenza di <code>pull-up</code> o di <code>pull-down</code>. Vedremo meglio con il circuito elettrico.</p> </li> <li> <p>Debouncing: quando si preme il pulsante, l'interruttore interno rimbalza pi\u00f9 volte prima di assestarsi. Di conseguenza l'ESP32 legge valori 0 e 1 che cambiano continuamente e il programma che esegue istruzioni in base agli input potrebbe funzionare male. Questo problema si pu\u00f2 risolvere con tecniche di <code>debouncing</code>. ( in seguito viene mostrata l'implementazione SW del debouncing)</p> </li> </ul> <p>Vediamo come \u00e8 fatto internamente un pulsante:</p> <p></p> <p>Di seguito \u00e8 indicato uno schema di collegamento di un pulsante:  </p> <p> </p> <p>NOTA: - Resistenza R2 serve per evitare che il segnali di input sia floating ma messo a un valore di riferimento di 1 (3.3V) - pull up - La resistenza R3 non \u00e8 indispensabile ma caldamento consigliata per proteggere il pin di ingresso GPIO da eventuali sovratensioni. E quindi dalla sua rottura.  - Si pu\u00f2 evitare di mettere il pullup esterno inserendone uno all'interno dell'ESP32 con il seguente comando:  Pin(14, Pin.IN, Pin.PULL_UP) </p>"},{"location":"corso/12_buttons/#gestione-debouncing","title":"Gestione debouncing","text":"<p>Quando si preme un pulsante fisico, il circuito si apre e si chiude decine o centinaia di volte. Questo fenomeno \u00e8 chiamato bouncing. Ci\u00f2 accade a causa della natura meccanica dei pulsanti: quando i contatti metallici si uniscono, c'\u00e8 un breve periodo in cui il contatto non \u00e8 perfetto, il che causa una serie di rapide transizioni di apertura/chiusura.</p> <p>NOTA PER il SIMULATORE Ovviamente, il pulsante del simulatore non ha problemi di contatti fisici, ma \u00e8 in grado di simularli impostando la variabile <code>Bounce</code> del pulsante:     - Se la imposti a <code>True</code>, il simulatore creer\u00e0 un centinaio di segnali aperto/chiuso ad ogni pressione del pulsante     - Se la imposti a <code>False</code>, il simulatore creer\u00e0 una singola coppia di segniali aperto/chiuso per ogni pressione.</p> <p>Di seguito viene mostrato una funzione che esegue il debouncing. In pratica quando si sente che il pulsante \u00e8 stato premuto (0), si aspetta altro tempo in modo da far passare il periodo dei rimbalzi(ad esempio 50msec) e si controlla se c'\u00e8 ancora 0.</p> <p><pre><code>import time\n\ndef debounce(pin, delay_ms=50):\n    \"\"\"\n    Ritorna True solo se il pulsante \u00e8 premuto\n    e il debounce \u00e8 passato.\n    \"\"\"\n    if pin.value() == 0:  # pulsante premuto (pull-up)\n        time.sleep_ms(delay_ms)\n        if pin.value() == 0:\n            return True\n    return False\n</code></pre> Di seguito, viene mostrato come usare la funzione debouncing.  </p> debouncing software<pre><code>from machine import Pin\n\nbutton = Pin(14, Pin.IN, Pin.PULL_UP)\n\nwhile True:\n    if debounce(button): # se ritorna True, allora fai qualcosa\n        print(\"Pulsante premuto\")\n        time.sleep_ms(300)  # evita ripetizioni\n</code></pre>"},{"location":"corso/12_buttons/#esempi-con-i-pulsanti","title":"Esempi con i pulsanti","text":"<p>In questo progetto di prova abbiamo un pulsante collegato ad un LED nel nostro circuito. Incredibilmente... quando si clicca il pulsante dovrebbe accendersi la luce!!!</p> <p></p> <p>Per ottenere questo effetto vogliamo collegare il pulsante in modalit\u00e0 PULL_DOWN e reagire quando questo viene premuto. Vediamo lo schema elettrico del progetto (ricordate che nel simulatore si pu\u00f2 evitare di mettere il pullup):</p> <p></p> <p>Quello che manca \u00e8 il codice di funzionamento. Eccolo:</p> <pre><code>from machine import Pin\n\n\nled = Pin(16, Pin.OUT)\nbutton = Pin(25, Pin.IN,Pin.PULL_DOWN)\n\nwhile True:\n    if button.value():\n        led.on()\n    else:\n        led.off()\n</code></pre>"},{"location":"corso/12_buttons/#esercizi","title":"Esercizi","text":"<p>Button LED_Bar</p> <p>Progetto contenente un pulsante e una barra dei led. Quando si clicca il pulsante, parte il caricamento della barra, che poi si scaricher\u00e0 quando \u00e8 tutta piena.</p> <p>Difficolt\u00e0 ulteriore: quando si clicca di nuovo il pulsante il caricamento si interrompe.  </p> <p>Lampeggio controllato Progetto in cui se si tiene premuto un secondo, il led lampeggio 5 volte, se si tiene premuto 3 secondi, il led lampeggia 10 volte.</p> <p></p> <p> </p>"},{"location":"corso/20_analog_pwm/","title":"Analog &amp;&amp; PWM","text":"<p>In questa sezione cercheremo di capire la (semplice) differenza fra segnali digitali e analogici e come essi possano essere realizzati e gestiti nelle nostre composizioni.</p> <p>Un segnale analogico \u00e8 un segnale continuo nel tempo e nella variazione di valore, mentre un segnale digitale \u00e8 un segnale discreto nel tempo e nella variazione di valore.</p> <p>La figura spiega molto chiaramente il concetto espresso:</p> <p></p> <p>In informatica ed elettronica si utilizzano molto spesso i segnali digitali binari identificati con 0 e 1, mentre ovviamente i segnali analogici hanno un range ben definito (ad esempio, fra 0 e A, per qualche A positivo e neanche troppo grande). Ovviamente esiste praticamente sempre un sistema di conversione dei segnali da digitale ad analogico e viceversa.</p>"},{"location":"corso/20_analog_pwm/#pulse-width-modulation","title":"Pulse Width Modulation","text":"<p>PWM \u00e8 una tecnologia che permette di utilizzare segnali digitali per controllare circuiti analogici. L\u2019idea \u00e8 quella di alternare per un certo periodo i segnali digitali 0 e 1, calcolando la percentuale di tempo in cui il segnale sta a 1: quell\u2019informazione \u00e8 detta duty cycle.</p> <p>\u00c8 chiaro che PWM non \u00e8 una reale trasformazione di un segnale da digitale ad analogico, ma che calcolando l\u2019energia trasportata nel periodo di pulsazione si riesce ad approssimare con efficacia la quantit\u00e0 analogica da rappresentare.</p> <p></p> <p></p> <p></p> <p>Esistono dispositivi hardware (a costi accessibili) in grado di implementare un grado di accuratezza fino a 10 bit, che significa distinguere fino a 1024 valori analogici diversi.</p> <p>L\u2019implementazione di PWM dell'ESP32 ha 8 canali separati, ognuno dei quali pu\u00f2 gestire la frequenza in maniera indipendente, cio\u00e8 ognuno dei Pin di output PWM sono configurabili a frequenze diverse.</p> <p>Per comprenderne il funzionamento, facciamo un esempio con il led programmabile (GPIO 5):</p> <pre><code>from machine import Pin,PWM\nimport time\n\n# il led da gestire\nledPin = Pin(5, Pin.OUT)\n\n# tempo di attesa in millisecondi\n# varia questo numero per aumentare/diminuire la velocit\u00e0 di illuminazione del led\nms_time = 100\n\n# l'oggetto per la gestione del PWM\n# richiede:\n# - l'oggetto fisico su cui applicare il PWM (nel nostro caso, il led)\n# - la frequenza in ms del pwm\npwm = PWM( ledPin, 10000)\n\nwhile True:\n\n    # qui si carica...\n    for i in range(0,1023):\n        pwm.duty(i)\n        time.sleep_ms(ms_time)\n\n    # ...qui si scarica.\n    for i in range(0,1023):\n        pwm.duty(1023 - i)\n        time.sleep_ms(ms_time)\n\n# ripulisce l'oggetto del PWM\npwm.deinit()\n</code></pre>"},{"location":"corso/20_analog_pwm/#breathing-led","title":"Breathing LED","text":"<p>Con \"Breathing LED\" si intende un LED che cambia la sua intensit\u00e0 luminosa in maniera continua e controllata. Il materiale necessario e schema circuitale sono gli stessi di qualunque progetto con un LED! In questo caso per\u00f2 bisogna essere sicuri che il pin di collegamento del LED supporti il PWM (cio\u00e8 che abbia la caratteristica \"ondina\" nello schema del GPIO).</p> <p>Il codice di gestione comprende il concetto di PWM cos\u00ec come la gestione del LED</p> <pre><code>from machine import Pin,PWM\nimport time\n\n# un pin che supporti output e PWM\npin = Pin(18, Pin.OUT)\n\npwm = PWM( pin,10000)\n\n# provate a modificare questo valore per osservare il cambio di comportamento\nsleep_time = 1\n\nwhile True:\n    for i in range(0,1023):\n        pwm.duty(i)\n        time.sleep_ms( sleep_time )\n\n    for i in range(0,1023):\n        pwm.duty(1023-i)\n        time.sleep_ms( sleep_time )\n\npwm.deinit()\n</code></pre> <p> </p>"},{"location":"corso/21_led_rgb/","title":"RGB Led","text":"<p>Un led RGB non \u00e8 altro che un led in grado di generare 3 differenti colori. Attivando i tre colori insieme e mescolandoli opportunamente con tecniche PWM \u00e8 possibile sostanzialmente ottenere qualsiasi colore.</p> <p></p> <p>Come si evince dalla figura, il LED RGB presenta un pin per ogni colore fondamentale della sintesi RGB pi\u00f9 un pin comune.</p> <p>Il <code>common pin</code> pu\u00f2 essere:</p> <ul> <li> <p>un <code>anodo</code> (positivo). In questo caso va collegato alla tensione 3.3V. Quando andremo a mettere a 0 il valore sul GPIO, il LED relativo si accende. Se scriviamo 1 il LED si spegne.</p> </li> <li> <p>un <code>catodo</code> (negativo). In questo caso va collegato al GND. La sintesi dei colori \u00e8 positiva (ZERO \u00e8 spento, UNO \u00e8 bianco). Quando andremo a mettere a 0 il valore sul GPIO, il LED relativo si spegne. Se scriviamo 1 il LED si accende.</p> </li> </ul> <p>Se accendiamo pi\u00f9 LED in contemporanea, avremo un colore risultante dato della combinazione dei colori R G B accesi in quel momento.  </p> <p>SINTESI ADDITIVA (RGB)</p> <p>La sintesi delle luci: se punti una luce rossa nello stesso punto di una luce verde, vedi una luce colore giallo!</p> <pre><code>I colori fondamentali di questa sintesi sono Rosso (Red), Verde (Green), Blu (Blue).\n\nLa somma dei 3 colori fondamentali fa il BIANCO!!!\n</code></pre> <p>Ogni colore fondamentale \"costa\" un byte, quindi ogni colore \"pesa\" 3 byte, ovvero sono rappresentabili 2 alla 24 colori diversi: circa 16 milioni di colori! Il web utilizza questa sintesi dei colori. La sua rappresentazione \u00e8 data dai 3 byte, tipicamente indicati con la sintassi esadecimale <code>#RRGGBB</code> Questa sintassi indica che i primi 2 numeri esadecimali rappresentano il byte che indica la quantit\u00e0 di rosso presente, i secondi la quantit\u00e0 di verde, gli ultimi la quantit\u00e0 di blu.</p> <pre><code>    Ad esempio:\n    #FF0000 rappresenta il rosso\n    #00FF00 rappresenta il verde\n    #0000FF rappresenta il blu\n    #000000 \u00e8 il nero\n    #FFFFFF \u00e8 il bianco\n    #888888 \u00e8 un grigio\n    #ADADAD \u00e8 un grigio pi\u00f9 chiaro\n    #FF8888 \u00e8 un rosso chiaro\n    ...\n</code></pre> <p></p>"},{"location":"corso/21_led_rgb/#progetto-led-colorato","title":"Progetto: LED colorato","text":"<p>Nel nostro progetto andiamo a comporre un circuito con un unico LED RGB con il pin comune come catodo e quindi collegato al GND:</p> <p>Infine testiamo il seguente codice:</p> <pre><code>from machine import Pin,PWM\nimport random\nimport time\n\npinR = Pin(19, Pin.OUT)\npinG = Pin(2,  Pin.OUT)\npinB = Pin(15, Pin.OUT)\npwmR = PWM(pinR,10000)\npwmG = PWM(pinG,10000)\npwmB = PWM(pinB,10000)\n\ncolors = {\"red\":(1023,0,0), \"green\":(0,1023,0), \"blue\":(0,0,1023),\"white\":(1023,1023,1023) }\n\nwhile True:\n  for color in colors:\n    (r,g,b) = colors[color]\n    print(color)\n    pwmR.duty(r)\n    pwmG.duty(g)\n    pwmB.duty(b)\n    time.sleep(2)\n\npwmR.deinit()\npwmG.deinit()\npwmB.deinit()\n</code></pre>"},{"location":"corso/21_led_rgb/#esercizi","title":"Esercizi","text":"<p>Semaforo</p> <p>Implementare un semaforo con un unico LED RGB: ogni 3 secondi la luce passa in maniera continua  da verde a giallo, poi dopo altri 3 secondi da giallo a rosso e dopo altri 3 secondi da rosso a verde.</p> <p>E poi si ricomincia.</p> <p>Modificare il progetto in modo da poter decidere liberamente la durata delle luci verde, gialla, rossa.</p> <p></p> <p>Luci Alternate</p> <p>Implementare un progetto con 2 luci LED semplici. Le luci si alternano in senso continuo, in modo che la somma dei 2 duty cycle sia sempre 100. Modificare il codice per fare in modo che ogni luce sia completamente accesa (e l\u2019altra completamente spenta) per 3 secondi.</p> <p></p> <p>LED e Pulsante</p> <p>Implementare un progetto con un pulsante e un LED. Il led \u00e8 inizialmente spento. Quando si clicca il pulsante, il led inizia ad accendersi fino ad essere completamente acceso, poi inizia a spegnersi e continua ad alternare le due fasi in maniera continua.</p> <p>Quando si clicca di nuovo il pulsante, l\u2019avanzamento si interrompe e la luce rimane ferma. Quando si clicca di nuovo la luce riparte dal punto in cui si era precedentemente fermata.</p> <p></p> <p>Caricamento barra dei LED</p> <p>Implementare un progetto con una barra dei led. Ogni led si accende dopo un secondo e quando la barra \u00e8 piena dopo un secondo ricomincia a spegnersi.</p> <p> </p>"},{"location":"corso/22_buzzer/","title":"Sensori: i buzzers","text":"<p>I buzzer sono dei componenti sonori utilizzati nei pi\u00f9 disparati dispositivi elettrici ed elettronici: nei calcolatori, negli orologi,  negli allarmi, nei cruscotti delle auto, nei campanelli delle case fino ai... cellulari!</p> <p>I tipi di buzzer che noi utilizzeremo sono molto semplici (e non troppo rumorosi) ma concettualmente identici a tutti gli altri,  diversi magari per dimensione e/o rumorosit\u00e0.</p> <p>I buzzer sono di due tipi:</p> <ol> <li>buzzer attivi: sono quelli che hanno un oscillatore al loro interno e che per suonare necessitano solo di essere alimentati</li> <li>buzzer passivi: necessitano di un oscillatore esterno (nel nostro caso un PWM) per emettere un suono.</li> </ol> <p></p> <p>I buzzer attivi sono semplicissimi da usare, ma tipicamente sono in grado di fare solo uno specifico suono. I buzzer passivi necessitano di un intero circuito per funzionare, ma di contro possono essere regolati per emettere suoni a frequenze differenti.</p> <p>Tipicamente il collegamento all'ESP32 di un buzzer \u00e8 il seguente:</p> <p></p>"},{"location":"corso/22_buzzer/#buzzer-attivo","title":"Buzzer attivo","text":"<p>Un buzzer attivo va semplicemente collegato come in figura e fatto suonare secondo il seguente codice:</p> <pre><code>from machine import Pin\nimport time\n\nbuzzer = Pin(33,Pin.OUT)\n\nbuzzer.off()\n\nwhile True:\n    buzzer.on()\n    time.sleep(1)\n    buzzer.off()\n    time.sleep(1)\n</code></pre>"},{"location":"corso/22_buzzer/#buzzer-passivo","title":"Buzzer passivo","text":"<p>Il collegamento elettrico del buzzer passivo \u00e8 concettualmente identico a quello attivo, ma va scelto un Pin di collegamento che supporti il PWM, che va gestito a livello di codice.</p> <pre><code>from machine import Pin,PWM\nimport math\nimport time\n\nPI = 3.14\n\npinB = Pin(33,Pin.OUT)\npassiveBuzzer = PWM( pinB, 2000)\n\n\npassiveBuzzer.init()\n\nfor x in range(0,36):\n    sinVal = math.sin(x*10*PI/180)\n    toneVal = 2000 + int(sinVal*500)\n    passiveBuzzer.freq(toneVal)\n    time.sleep_ms(10)   \n\npassiveBuzzer.deinit()\n</code></pre> <p>Tutto qua! Adesso, sotto con i progetti!!!</p>"},{"location":"corso/22_buzzer/#esercizi","title":"Esercizi","text":"<p>Ecco alcuni degli esercizi sui buzzer e sui sensori che abbiamo gi\u00e0 studiato. Provate a fare i primi e ad arricchirli come credete!</p> <p>Buon divertimento!!!</p> <p>Campanello</p> <p>Implementare un progetto con un buzzer (attivo) e un pulsante. Quando si tiene cliccato il pulsante suona l'allarme, che ha il tipico suono ondulato che varia dall\u2019acuto al grave in maniera continua.</p> <p>Allarme</p> <p>Come il precedente ma stavolta con un buzzer passivo. Implementare un progetto con un buzzer e un pulsante (come il precedente). Quando si tiene cliccato il pulsante suona il buzzer!</p> <p>Sirena</p> <p>Implementare un progetto con un buzzer che suona per 2 secondi ogni 3 secondi.</p> <p>Luce e Suono</p> <p>Aggiungete una luce a LED al progetto precedente. Quando il buzzer suona, la luce deve accendersi.</p> <p>Barra dei led e suono</p> <p>Implementare un progetto con un buzzer passivo e una barra dei led. Quando il buzzer suona la barra dei led si accende.  Pi\u00f9 \u00e8 acuto il suono, pi\u00f9 la barra deve \"caricarsi\". La barra va spenta completamente solo quando il suono \u00e8 spento.</p> <p> </p>"},{"location":"corso/30_ADC/","title":"ADC","text":"<p>Un <code>ADC (Analog Digital Converter)</code> \u00e8 un circuito elettronico integrato utilizzato per convertire segnali analogici, come le tensioni, in forma digitale, come sequenza binaria. Questa operazione \u00e8 definita <code>campionamento</code>.</p> <p>L'ADC sui nostri ESP32 lavora ad una tensione di 3.3V e avendo un intervallo di input di 12 bit, presenta una risoluzione di 2<sup>12</sup> = 4096. Questo significa che, se con un numero reale puoi rappresentare qualunque valore fra 0 e 3.3, con il nostro ADC puoi solamente dividerlo in 4096 parti e rappresentare quelle frazioni della tensione grazie ad un numero binario.</p> <p>L'errore di misura che si introduce viene definito errore di quantizzazione.</p> <p></p> <p></p> <p></p> <p>L'ESP32 ha due ADC con 12 bit di accuratezza e un totale di 16 pin suddivisi fra i due ADC. Pi\u00f9 precisamente:</p> <p></p> <p>Attenzione</p> <p>Se si utilizza la scheda Wifi/Bluetooth integrata nell'ESP32, l'ADC2 e tutte le porte GPIO riconducili ad essa diventano inutilizzabili!!!</p> <p>Bisogna valutare bene il da farsi...</p> <p> </p>"},{"location":"corso/31_potentiometer/","title":"Potenziometri","text":"<p>Un potenziometro \u00e8 una manopola che traduce il grado di posizionamento della stessa in una tensione percentuale rilasciata come valore di output.</p> <p>Si presenta come un dispositivo con 3 connettori, tali che:</p> <ul> <li>uno va collegato al GND</li> <li>uno va collegato ad un pin</li> <li>uno va collegato alla tensione (3.3v oppure 5v)</li> </ul> <p>Ovviamente il valore rilasciato dal sensore \u00e8 un valore analogico e quindi, a livello elettronico, il potenziometro ha bisogno di un ADC per restituire valori digitali.</p> <p></p> <p>Il codice indicato visualizza una serie di valori (uno ogni decimo di secondo) che rappresentano la posizione percentuale (in scala 0-4095) della manopola del potenziometro.</p> <p></p> Potenziometro<pre><code># In questo esempio i valori restituiti dovrebbero andare da 0 a 4095\nfrom machine import Pin,ADC\nimport time\n\nadc=ADC(Pin(33))\nadc.atten(ADC.ATTN_11DB)\nadc.width(ADC.WIDTH_12BIT)\n\nwhile True:\n    adcValue = adc.read()\n    print(\"Value:\", adcValue)\n    time.sleep_ms(100)\n</code></pre> <p>Tutto qua! Adesso, sotto con i progetti!!!</p>"},{"location":"corso/31_potentiometer/#esercizi","title":"Esercizi","text":"<p>Qualche   </p>"},{"location":"corso/32_joystick/","title":"Joystick con ESP32","text":"<p>Un joystick \u00e8 un dispositivo di input utilizzato per controllare la  posizione di un cursore o di un oggetto su uno schermo,  soprattutto nei contesti di videogiochi, simulatori di volo o altre applicazioni interattive.  Si tratta di una leva o di un dispositivo simile che pu\u00f2 essere spostato in diverse direzioni per controllare il movimento di un cursore o di un'entit\u00e0 virtuale.</p> <p>I joystick possono avere varie forme e dimensioni,  ma in genere consistono in una leva che pu\u00f2 essere inclinata o spostata  in diverse direzioni.</p> <p>Esso fornisce al processore i segnali elettrici relativi alla posizione di due, l'asse X e l'asse Y.  Inoltre il joystick ha a disposizione anche l'asse Z  che ci servir\u00e0 per indicare la pressione o meno del joystick stesso.</p> <p></p> <p>In figura vediamo  i collegamenti elettrici che il nostro joystick richiede:</p> <ul> <li>Il collegamento al GND</li> <li>L'alimentazione a 5V (3.3V per il nostro joystick)</li> <li>L'asse X (valori da 0 a 4095)</li> <li>L'asse Y (valori da 0 a 4095)</li> <li>L'asse Z (valori da 0 a 1)</li> </ul> <p>I due segnali VRX e VRY (per gli assi X e Y) sono due segnali analogici che andranno  collegati direttamenti a due pin GPIO del componente ESP32 con  funzione ADC di convertitore Analogico-Digitale.</p>"},{"location":"corso/32_joystick/#codice","title":"Codice","text":"<p>I segnali elettrici collegati ai pin 13 e 14 vengono trasformati in segnali digitali (numeri) In pratica il valore di tensione in ingresso andr\u00e0 da un valore di 0V a un valore di 3.3V a seconda della posizione del  joystick. I corrispondenti valori digitali saranno 0 (per 0V) e 4095 (per 3.3V).</p> <p>Al pin 12 arriver\u00e0 in input o un valore basso (0 o LOW) o valore alto (1 o HIGH)  a seconda se il pin verr\u00e0 premuto o meno.</p> <p>Il codice \u00e8 sotto riportato.</p> <pre><code>from machine import ADC,Pin\nimport time\n\nxJoy = ADC(Pin(14)) # ADC sta per Analog-Conversion Converter\nyJoy = ADC(Pin(13))\nzJoy = Pin(12,Pin.IN,Pin.PULL_UP) # secondo l'asse Z, il joystick \u00e8 come un pulsante\n\n# impostano la dimensione di X,Y fra 0 e 4095\nxJoy.atten(ADC.ATTN_11DB)\nyJoy.atten(ADC.ATTN_11DB)\nxJoy.width(ADC.WIDTH_12BIT)\nyJoy.width(ADC.WIDTH_12BIT)\n\nwhile True:\n  x = xJoy.read()\n  y = yJoy.read()\n  z = zJoy.value()\n  print(\"X,Y,Z:\" , x , \",\" , y , \",\" , z )\n  time.sleep(1)\n</code></pre> <p>Quello che dovreste vedere sar\u00e0 qualcosa del genere:</p> <p></p>"},{"location":"corso/33_keypad/","title":"Keypad","text":"<p>Una keypad non \u00e8 altro che una pulsantiera in cui dovete imparare a gestire i tasti con il gioco della battaglia navale!!!</p> <p></p> <p>Sostanzialmente abbiamo 16 tasti in cui ognuno viene individuato da una coppia di pin, come nel gioco battaglia navale </p> <p>la gestione di una keypad \u00e8 un lungo problema semplice. Vi lascio un codice funzionante, una volta stabiliti i  pin di collegamento della stessa.</p> <p></p> class Keypad<pre><code>from machine import Pin\nimport time\n\nlastChangeTime=0\nkeyState=0\nState=0\n\nclass KeyPad(object):\n    def __init__(self, row1: int=14, row2: int=27, row3: int=26, row4: int=25, col1: int=13, col2: int=21, col3: int=22, col4: int=23):\n        self._row1=Pin(row1,Pin.OUT)\n        self._row2=Pin(row2,Pin.OUT)\n        self._row3=Pin(row3,Pin.OUT)\n        self._row4=Pin(row4,Pin.OUT)\n        self._col1=Pin(col1,Pin.IN,Pin.PULL_DOWN)\n        self._col2=Pin(col2,Pin.IN,Pin.PULL_DOWN)\n        self._col3=Pin(col3,Pin.IN,Pin.PULL_DOWN)\n        self._col4=Pin(col4,Pin.IN,Pin.PULL_DOWN)\n\n\n    def scan(self):\n        global lastChangeTime\n        nowTime=time.ticks_ms()\n        if(nowTime-lastChangeTime&gt;10):\n            lastChangeTime=nowTime\n            if(self._readCol()!=0):\n                State=self._readCol()\n                return State\n\n    def _readRow1(self):\n        self._setRow(1)\n        if(self._col1.value()==1):\n            keyState='1'\n        elif(self._col2.value()==1):\n            keyState='2'\n        elif(self._col3.value()==1):\n            keyState='3'\n        elif(self._col4.value()==1):\n            keyState='A'\n        else:\n            keyState=0\n        return keyState\n\n    def _readRow2(self):\n        self._setRow(2)\n        if(self._col1.value()==1):\n            keyState='4'\n        elif(self._col2.value()==1):\n            keyState='5'\n        elif(self._col3.value()==1):\n            keyState='6'\n        elif(self._col4.value()==1):\n            keyState='B'\n        else:\n            keyState=0 \n        return keyState\n\n    def _readRow3(self):\n        self._setRow(3)\n        if(self._col1.value()==1):\n            keyState='7'\n        elif(self._col2.value()==1):\n            keyState='8'\n        elif(self._col3.value()==1):\n            keyState='9'\n        elif(self._col4.value()==1):\n            keyState='C'\n        else:\n            keyState=0 \n        return keyState\n\n    def _readRow4(self):\n        self._setRow(4)\n        if(self._col1.value()==1):\n            keyState='*'\n        elif(self._col2.value()==1):\n            keyState='0'\n        elif(self._col3.value()==1):\n            keyState='#'\n        elif(self._col4.value()==1):\n            keyState='D'\n        else:\n            keyState=0\n        return keyState\n\n    def _readCol(self):\n        data_buffer1=self._readRow1()\n        data_buffer2=self._readRow2()\n        data_buffer3=self._readRow3()\n        data_buffer4=self._readRow4()\n        if (data_buffer1!=0):\n            return data_buffer1\n        elif (data_buffer2!=0):\n            return data_buffer2\n        elif (data_buffer3!=0):\n            return data_buffer3\n        elif (data_buffer4!=0):\n            return data_buffer4\n\n    def _setRow(self,num):\n        if num==1:\n            self._row1.on()\n            self._row2.off()\n            self._row3.off()\n            self._row4.off()\n        if num==2:\n            self._row1.off()\n            self._row2.on()\n            self._row3.off()\n            self._row4.off()\n        if num==3:\n            self._row1.off()\n            self._row2.off()\n            self._row3.on()\n            self._row4.off()\n        if num==4:\n            self._row1.off()\n            self._row2.off()\n            self._row3.off()\n            self._row4.on()\n</code></pre> keypad reader<pre><code>from keypad import KeyPad\nimport time\n\nkeyPad=KeyPad(14,13,12,11,10,9,8,18)\n\nwhile True:\n    keyvalue=keyPad.scan()\n    if keyvalue!= None:\n        print('Your input:',keyvalue)\n        time.sleep_ms(200)\n</code></pre> <p> </p>"},{"location":"corso/34_photoresistor/","title":"Photoresistori","text":"<p>Blah blah...</p> <p> </p>"},{"location":"corso/41_display/","title":"LCD Display(s)","text":""},{"location":"corso/42_IR/","title":"InfraRossi","text":"<p>Blah blah...</p> <p></p> Esempio con il ricevitore a infrarossi<pre><code># codice da semplificare\n# e commentare adeguatamente!!!\n</code></pre> <p> </p>"},{"location":"corso/43_distance/","title":"Ultrasonic Distance Sensors","text":"<p>Il sensore a ultrasuoni utilizza il principio (appunto) degli ultrasuoni per avere informazioni sulla presenza e posizione di eventuali ostacoli davanti a s\u00e8. Inoltre, calcolando l'intervallo di tempo fra l'invio e la ricezione dell'ultrasuono, \u00e8 possibile fare una stima della distanza a cui l'ostacolo si trova.</p> <p>Questo sensore lavora con una tensione di esercizio di 5V (e alla corrente di 12 mA) e riesce a misurare distanze comprese fra 2 e 200 cm.</p> <p></p> Esempio con il sensore di distanza<pre><code># sto codice va spiegato passo passo...\nfrom machine import Pin\nimport time\n\ntrigPin=Pin(33,Pin.OUT,0)\nechoPin=Pin(32,Pin.IN,0)\n\nsoundVelocity = 340\ndistance = 0\n\n# aspetta due secondi che il sensore si attivi...\ntime.sleep_ms(2000)\n\nwhile True:\n    trigPin.value(1)\n    time.sleep_us(10)\n    trigPin.value(0)\n    while not echoPin.value():\n        pass\n    pingStart=time.ticks_us()\n    while echoPin.value():\n        pass\n    pingStop = time.ticks_us()\n    pingTime = time.ticks_diff(pingStop,pingStart)\n    distance = int(pingTime*soundVelocity//2//10000)\n\n    print('Distance: ',distance,'cm' )\n    time.sleep_ms(500)\n</code></pre> <p> </p>"},{"location":"corso/44_DHT22/","title":"DHT22","text":"<p>Blah blah...</p> <p>The DHT driver is implemented in software and works on all pins:</p> <pre><code>from machine import Pin\nimport dht\n\n# questo in caso di sensore DHT11...\nd = dht.DHT11( Pin(4) )\nd.measure()\nd.temperature() # eg. 23 (\u00b0C)\nd.humidity()    # eg. 41 (% RH)\n\n# questo per il sensore DHT22...\nd = dht.DHT22( Pin(4) )\nd.measure()\nd.temperature() # eg. 23.6 (\u00b0C)\nd.humidity()    # eg. 41.3 (% RH)\n</code></pre> <p> </p>"},{"location":"corso/45_motion/","title":"Motion","text":"<p>Sensore di movimento a infrarossi.</p> <pre><code># scrivimi\n</code></pre> <p> </p>"},{"location":"corso/50_forchetta/","title":"Umidit\u00e0 del terreno","text":"<p>In questo capitolo impareremo ad usare un sensore da infilare nel terreno (ad esempio in un vaso o in giardino) in modo da misurare il livello di umidit\u00e0 e quindi sapere quando \u00e8 ora di annaffiare.  </p>"},{"location":"corso/51_PM/","title":"Particolato PM10 e PM2.5","text":"<p>In questo capitolo impareremo ad usare un sensore capace di misurare il livello di inquinamento dell'aria in base alla presenza di particelle piccolissime ma allo stesso modo pericolose per il corpo umano.  </p>"},{"location":"corso/99_network/","title":"Connettere l'ESP32","text":"<p>In questa parte del corso andremo ad esplorare le potenzialit\u00e0 di rete presenti in ESP32! In particolare vedremo:</p> <ul> <li>come collegare l'ESP32 ad una rete WIFI</li> <li>come configurare l'ESP32 per creare una propria rete Wifi, a cui far connettere altri dispositivi.</li> <li>come gestire la connettivit\u00e0 Bluetooth, presente nel microcontrollore.</li> </ul> <p>Per la gestione del Wifi, si utilizza il modulo <code>network</code>, gi\u00e0 disponibile nel bundle MicroPython.</p> <p>Vediamo come</p>"},{"location":"corso/99_network/#funzionalita-del-modulo-network","title":"Funzionalit\u00e0 del modulo network","text":"<p>A volte visualizzare un p\u00f2 di codice ben commentato rende le cose pi\u00f9 semplici che tante parole...</p> <p></p> <p>IMPORTA il modulo network.</p> <pre><code>import network\n</code></pre> <p></p> <p>CREA l'oggetto interfaccia WLAN</p> <pre><code># l'opzione network.STA_IF crea una interfaccia in grado di connettersi ad una rete Wifi\nwlan = network.WLAN(network.STA_IF)\n\n# l'opzione network.AP_IF crea una interfaccia Access-Point\nwlan = network.WLAN(network.AP_IF)\n</code></pre> <p></p> <p>CONFIGURA, se necessario, l'oggetto interfaccia WLAN</p> <pre><code># Imposta il nome (si chiama SSID) della rete Wifi\nwlan.config(ssid='NomeReteWifi')\n# oppure\nwlan.config(ssid='NomeReteWifi' , security=3 , key=\"PasswordReteWifi\")\n</code></pre> <p></p> <p>ATTIVA l'interfaccia</p> <pre><code>wlan.active(True)\n</code></pre> <p></p> <p>ESEGUI le operazioni che ritieni necessarie. Qui ho elencato alcuni esempi in ordine sparso...</p> <pre><code># scansiona per individuare le reti Wifi disponibili \nnetwork_list = wlan.scan()\n\n# connette l'interfaccia WLAN alla rete Wifi SSID con chiave KEY\nwlan.connect('ssid', 'key')\n\n# controlla SE l'interfaccia \u00e8 connessa al Wifi.\n# Ritorna True/False\nwlan.isconnected()\n\n# visualizza la configurazione di rete.\n# Ritorna la tupla ( 'IP', 'SubnetMask' , 'gateway' , 'DNS')\nwlan.ifconfig()\n\n# configura la rete del dispositivo con le seguenti impostazioni: ( 'IP', 'SubnetMask' , 'gateway' , 'DNS')\nwlan.ifconfig( ('IP','SubnetMask','gateway','DNS') )\n</code></pre>"},{"location":"corso/99_network/#collegarsi-ad-una-rete-wifi","title":"Collegarsi ad una rete Wifi","text":"<p>Vediamo un paio di esempi di collegamento ad una rete wifi da parte del dispositivo ESP32. Nel primo andremo ad acquisire automaticamente le informazioni di rete, nel secondo andremo ad impostarle manualmente appena possibile.</p> <p></p> Connessione ad una rete WIFI ed indirizzamento tramite DHCP<pre><code>import network\nimport time\n\nwlan = network.WLAN(network.STA_IF)\nwlan.active(True)\n\n# connette l'interfaccia WLAN alla rete Wifi SSID con chiave KEY\nwlan.connect('ssid', 'key')\n\nwhile not wlan.isconnected():\n    print(\"Connecting...\")\n    time.sleep(0.5)\n\nprint(\"CONNECTED\")\nprint(\"Network settings:\", wlan.ifconfig())\n</code></pre> <p>Bene! Adesso impostiamo manualmente le informazioni di rete</p> Connessione ad una rete WIFI con indirizzamento statico<pre><code>import network\nimport time\n\nwlan = network.WLAN(network.STA_IF)\nwlan.active(True)\n\n# connette l'interfaccia WLAN alla rete Wifi SSID con chiave KEY\nwlan.connect('ssid', 'key')\n\n# configurazione di rete: Questi numeri potrebbero funzionare a scuola, con una opportuna x fra 1 e 254\nwlan.ifconfig( ('10.10.12.x','255.255.0.0','10.10.0.1','8.8.8.8') )\n\nwhile not wlan.isconnected():\n    print(\"Connecting...\")\n    time.sleep(0.5)\n\nprint(\"CONNECTED\")\n</code></pre>"},{"location":"corso/99_network/#creare-una-rete-wifi-ad-hoc","title":"Creare una rete Wifi Ad-hoc","text":"<p>Il codice che presentiamo adesso serve invece a configurare l'interfaccia WLAN per creare una propria rete Wifi, a cui evetualmente far connettere altri dispositivi.</p> <p>Vediamo il codice:</p> <pre><code>import network\n\n# crea l'oggetto interfaccia WLAN con opzione network.AP_IF\nwlan = network.WLAN(network.AP_IF)\n\n# Imposta il nome (si chiama SSID) della rete Wifi\nwlan.config(ssid='NomeReteWifi')\n# oppure\nwlan.config(ssid='NomeReteWifi' , security=3 , key=\"PasswordReteWifi\")\n\n# attivala\nwlan.active(True)\n</code></pre> <p>L'IP predefinito in modalit\u00e0 Access Point \u00e8 <code>192.168.4.1</code>. I client connessi partono da <code>.2</code>.</p> <p>Se voleste elencare i client connessi...</p> <pre><code>while True:\n    clients = ap.status(\"stations\")\n    print(f\"[WIFI] {len(clients)} stations connected\")\n    for mac in clients:\n        for m in mac:\n            smac = f\"{m[0]:02x}:{m[1]:02x}:{m[2]:02x}:{m[3]:02x}:{m[4]:02x}:{m[5]:02x}\"\n            print(f\"[WIFI] Station connected: {smac}\")\n\n    time.sleep(1)\n</code></pre>"},{"location":"corso/99_network/#webrepl","title":"WebREPL","text":"<p>Tip</p> <p><code>REPL</code> sta per <code>Read Evaluate Print Loop</code> e non \u00e8 nient'altro che il nome tecnico del prompt dei comandi di Python. Sarebbe quella cosina dopo i 3 maggiori (<code>&gt;&gt;&gt;</code>) che permette il pi\u00f9 velocemente possibile di eseguire un comando o di controllare il valore di una variabile.</p> <p>Per accedere al prompt di MicroPython ci sono due modi:</p> <ol> <li> <p>collegando l'esp32 tramite USB al PC e interfacciandosi sulla porta virtuale seriale che si crea automaticamente. (Su Windows, sono le porte COM + un numero; su Linux e Mac, le porte ttyUSB + un numero).</p> </li> <li> <p>collegandosi tramite wifi alla cosiddetta <code>WebREPL</code>.</p> </li> </ol> <p>Ovviamente noi qui ci occupiamo del secondo caso. Alcune piccole precisazioni preliminari:</p> <ul> <li> <p>per connetterci alla <code>WebREPL</code> dobbiamo prima di tutto essere collegati al wifi (e fino a qui...)</p> </li> <li> <p>per instaurare una connessione alla <code>WebREPL</code> dell'esp32 occorre un <code>WebREPL Client</code>. Neanche a dirlo... <code>Thonny</code> ne ha uno incluso al suo interno... senza dover fare nulla!!!</p> </li> </ul> <p>Per utilizzare <code>WebREPL</code> dobbiamo prima di tutto configurarlo al meglio! Digitate nel prompt il seguente comando:</p> <pre><code>import webrepl_setup\n</code></pre> <p>Abilitate l'esecuzione automatica all'avvio e scegliete la password di accesso.</p> <p>Note</p> <p>Facciamola facile!!! Mettiamo tutti la password <code>esp32</code>. </p> <p>Ci sar\u00e0 tempo per fare l'hardening del nostro sistema. Adesso favoriamo la semplicit\u00e0 di configurazione!!!</p> <p>Warning</p> <p>Terminata la configurazione webrepl dell'esp32, apparir\u00e0 nel suo filesystem un file chiamato <code>webrepl_cfg.py</code>, contenente, tra le altre cose, la password selezionata!</p> <p>Non dovete toccarlo, modificarlo, cancellarlo... niente!!!</p> <p>Altrimenti tutto risulter\u00e0 perfettamente inutile...</p> <p>Una volta individuato l'IP del vostro sistema riavviate l'esp32 e procedete a connettervi tramite <code>WebREPL</code>. Ecco le operazioni da fare su Thonny:</p> <p>Sulle opzioni...</p> <p></p> <p>Infine, quando avete riavviato l'esp32, provate a connettervi selezionando il prompt corretto.</p> <p></p>"},{"location":"corso/99_network/#web-server","title":"Web Server","text":"<p>Un semplice esempio di web server, per poter studiare e modificare un pochino il codice, per accendere e spegnere il led di sistema dell'ESP32</p> <pre><code># THE led\nimport machine\nled = machine.Pin(5, machine.Pin.OUT)\nled.off()\n\n# THE web server\nimport socket\n\n# ....\nserver = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nserver.bind(('0.0.0.0', 80))\nserver.listen(8) # max number of simultaneous connections\nserver.setblocking(False)\n\nwhile True:\n    conn, addr = server.accept()\n    print('Got a connection from ', str(addr))\n\n    request = str( conn.recv(1024) )\n    request_line = request.split('\\n')[0]\n\n    if 'led=on' in request_line:\n        print('LED ON')\n        led.on()\n    if 'led=off' in request_line:\n        print('LED OFF')\n        led.off()\n\n    html = \"\"\n    html += '&lt;h1&gt;Web LED&lt;/h1&gt;' \n    html += '&lt;a href=\"/?led=on\"&gt;&lt;button class=\"button\"&gt;ON&lt;/button&gt;&lt;/a&gt;'\n    html += '&lt;a href=\"/?led=off\"&gt;&lt;button class=\"button button2\"&gt;OFF&lt;/button&gt;&lt;/a&gt;'\n\n    conn.send('HTTP/1.1 200 OK\\n')\n    conn.send('Content-Type: text/html\\n')\n    conn.send('Connection: close\\n\\n')\n    conn.sendall(html)\n    conn.close()\n</code></pre>"},{"location":"corso/99_network/#async-web-server","title":"Async Web Server","text":"<p>Questo codice \u00e8 sperimentale. L'ho scritto durante le vacanze di Natale... </p> <pre><code>import asyncio\nimport socket\n\nasync def handle_client(client):\n    loop = asyncio.get_event_loop()\n\n    request = (await loop.sock_recv(client, 1024)).decode('utf8')\n    request_line = request.split('\\n')[0]\n    print(\"request line:\", request_line)\n\n    reply = ''\n    reply += 'HTTP/1.1 200 OK\\n'\n    reply += 'Content-Type: text/html\\n'\n    reply += 'Connection: close\\n\\n'\n\n    if 'led=on' in request_line:\n        print('LED ON')\n    if 'led=off' in request_line:\n        print('LED OFF')\n\n    reply += '&lt;h1&gt;Web LED&lt;/h1&gt;' \n    reply += '&lt;a href=\"/?led=on\"&gt;&lt;button class=\"button\"&gt;ON&lt;/button&gt;&lt;/a&gt;'\n    reply += '&lt;a href=\"/?led=off\"&gt;&lt;button class=\"button button2\"&gt;OFF&lt;/button&gt;&lt;/a&gt;'\n    reply += '\\n'\n\n    await loop.sock_sendall(client, reply.encode('utf8'))\n    client.close()\n\nasync def run_server():\n    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    server.bind(('0.0.0.0', 8080))\n    server.listen(8) # max number of simultaneous connections\n    server.setblocking(False)\n\n    loop = asyncio.get_event_loop()\n\n    while True:\n        client, addr = await loop.sock_accept(server)\n        loop.create_task(handle_client(client))\n\n# -----------------------------------------------------------------------------\nif __name__ == \"__main__\":\n    asyncio.run(run_server())\n</code></pre>"},{"location":"corso/99_network/#bluetooth","title":"Bluetooth","text":"<p>Quando arriva, arriva...</p> <p> </p>"},{"location":"tutorials/00_intro/","title":"I Tutorial","text":"<p>In questa sezione troverete alcune esperienze singole per sviluppare una tematica specifica.</p> <p>Attenzione!!! Potrebbe essere interessante... o perfino divertente...</p> <p> </p>"},{"location":"tutorials/04_simulator/","title":"Esp32 Simulator","text":"<p>Per poter lavorare con i dispositivi ESP32 e tutti i sensori anche da casa o in generale, senza apparecchiare tutto il laboratorio di materiale, \u00e8 possibile ricorrere ad uno dei tanti progetti di simulazione dell'hardware. </p> <p>Quello che ha pi\u00f9 colpito la nostra attenzione si chiama https://wokwi.com/ ed  \u00e8 una applicazione web per la simulazione di progetti IoT direttamente nel browser.</p>"},{"location":"tutorials/04_simulator/#istruzioni-operative","title":"Istruzioni Operative","text":"<p>Suggerimento</p> <p>Le seguenti istruzioni valgono per lavorare su un dispositivo virtuale il pi\u00f9 possibile identico all'esp32 che abbiamo a scuola.</p> <p>I prof stanno lavorando per renderlo disponibile di default su wokwi!!!</p> <ol> <li> <p>Scarica il seguente file zip ed estrai la cartella <code>esp32-wroom-32</code> sul tuo computer</p> </li> <li> <p>Clicca qui per creare un nuovo progetto</p> </li> <li> <p>Premi <code>F1</code> sull'editor e nella tendina di selezione cerca \"Load custom board file...\"</p> </li> <li> <p>Carica la cartella <code>esp32-wroom-32</code> scaricata precedentemente.</p> </li> <li> <p>Modifica il file <code>diagram.json</code> in questo modo:</p> file diagram.json modificato<pre><code>{\n  \"version\": 1,\n  \"author\": \"il tuo nome e cognome\",\n  \"editor\": \"wokwi\",\n  \"parts\": [\n    {\n      \"type\": \"wokwi-custom-board\",\n      \"id\": \"esp\",\n      \"attrs\": { \"env\": \"micropython-20231227-v1.22.0\" }\n    }\n  ],\n   \"connections\": [\n     [ \"esp:TX\", \"$serialMonitor:RX\", \"\", [] ],\n     [ \"esp:RX\", \"$serialMonitor:TX\", \"\", [] ]\n   ],\n  \"dependencies\": {}\n}\n</code></pre> </li> <li> <p>Salva e sei pronto all'azione!! (indica il nome del tuo progetto! Ad esempio, ProvaLED)</p> </li> <li> <p>Modifica il tuo progetto hardware aggiungendo led, resistenze, collegamenti e tutto quanto necessario</p> </li> <li> <p>Scrivi il codice nell'editor online (file <code>main.py</code>) e testalo avviando l'esp32 virtuale.</p> </li> <li> <p>Quando hai finito, scarica il progetto (file <code>ProvaLED.zip</code>, contenente almeno i file <code>main.py</code> e <code>diagram.json</code>) dal men\u00f9 in alto, facendo <code>Download project.zip</code></p> </li> <li> <p>Consegna i compiti inviando il file <code>zip</code> al docente!</p> </li> </ol> <p>Adesso non hai pi\u00f9 alcuna scusa per non fare i compiti a casa!!!</p> <p> </p>"},{"location":"tutorials/10_socket/","title":"Socket Programming","text":"<p>I socket sono oggetti software gestiti dal Sistema Operativo. Sono gli unici responsabili per qualunque connessione di rete. Anzi... pi\u00f9 precisamente una connessione di rete non \u00e8 altro che uno scambio di dati fra due socket! E chi chiede al sistema operativo di creare i socket? Le applicazioni!!!</p> <p>I socket permettono anche ai dispositivi di veicolare contemporaneamente pi\u00f9 connessioni logiche (ad esempio, due schede di un browser aperte) attraverso un'unica connessione fisica! Pi\u00f9 precisamente, per ogni dispositivo fisico di connessione alla rete sono disponibili 65.536 porte logiche  per la possibile creazione di altrettanti socket!</p> <p></p> <p></p> <p></p> <p>Come si evince chiaramente dalla figura, Ogni socket si individua grazie alla coppia di informazioni: <code>IP</code>, <code>PORTA LOGICA</code>.</p> <p>Ogni connessione alla rete viene individuata univocamente (nell'unit\u00e0 di tempo) dalla coppia di socket  che fanno da mittente e destinatario della stessa. </p> <p>Il livello di trasporto pu\u00f2 fornire due tipi di servizi, definiti in due protocolli diversi:</p> <ul> <li>Il protocollo TCP, per le connessioni punto a punto (1 a 1); connesso e affidabile</li> <li>Il protocollo UDP per le connessioni semplici (anche broadcast e multicast) senza alcuna sovrastruttura: non connesso e non affidabile.</li> </ul> <p>Ok... la teoria la sappiamo! Vediamo il codice adesso.</p>"},{"location":"tutorials/10_socket/#socket-in-python","title":"Socket in Python","text":"<p>Come dicevamo, i socket sono oggetti software gestiti dal Sistema Operativo e invocati dalle applicazoini. Come si crea un socket in Python??</p> <pre><code>import socket\n\n# Oggetto Socket TCP\ntcp_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n\n# Oggetto Socket UDP\nudp_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n</code></pre> <p>Anche qui... non mi sembra complicato :)</p> <p>Faremo adesso una prova di comunicazione client-server tramite il protocollo UDP.</p>"},{"location":"tutorials/10_socket/#comunicazione-clientserver-udp-in-python","title":"Comunicazione client/server UDP in Python","text":"<p>Vediamo il codice che crea un server con il protocollo UDP. Questo semplice programma si mette in attesa di comunicazioni. Poi a seconda del messaggio arrivato risponde OK se il numero di lettere arrivate \u00e8 pari, ERR se sono dispari.</p> UDP Server in Python<pre><code>import socket\nimport time\n\nlocalIP = \"192.168.110.200\"  # Qui ci va il tuo IP, come stringa\nlocalPort = 20000            # Qui ci va una porta (&gt; 1024), come intero\n\n# UDP Socket Object\nudp_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n\n# Bind to address and ip\nudp_socket.bind( (localIP, localPort) )\n\nprint(\"UDP server up and listening\")\n\n# Listen for incoming datagrams\nwhile True:\n    message,address = udp_socket.recvfrom(1024)\n\n    time.sleep(0.1)\n    print(\"Message from Client:\", message.decode() )\n    print(\"Client IP Address:\", address)\n\n    msgFromServer = \"OK\"\n    if len(message) % 2 == 1:\n        msgFromServer = \"Err\"\n    bytesToSend = str.encode(msgFromServer)\n\n    # Sending a reply to client\n    udp_socket.sendto(bytesToSend, address)\n</code></pre> <p></p> <p>Ovviamente abbinato al server, che deve essere in esecuzione, ci va un client che deve tentare la connessione e l'invio allo stesso. Ecco il codice che permette di inviare al server un messaggio qualunque.</p> <p></p> UDP Client in Python<pre><code>import socket\nimport time\n\nServer_IP   = \"192.168.110.200\"  # Qui ci va l'IP del dispositivo che esegue il tuo server, come stringa\nServer_PORT = 20000              # Qui ci va la porta del tuo server (la devi sapere), come intero\n\nMESSAGE = input(\"text to send: \")\n\nprint(\"UDP target IP: \", Server_IP)\nprint(\"UDP target port: \", Server_PORT)\nprint(\"message: \", MESSAGE)\n\n# UDP Socket Object\nudp_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\nudp_socket.sendto(MESSAGE.encode(), (Server_IP, Server_PORT))\n\ntime.sleep(0.1)\n\nmessage,address = udp_socket.recvfrom(1024)\n\nprint(\"Reply from Server:\", message.decode() )\nprint(\"Server IP Address:\", address)\n</code></pre> <p>Adesso basta solo provare :)</p>"},{"location":"tutorials/10_socket/#comunicazione-clientserver-tcp-in-python","title":"Comunicazione client/server TCP in Python","text":"<p>TCP \u00e8 un protocollo ben pi\u00f9 complicato di UDP! Vi espongo le differenze fondamentali:</p> <ul> <li>il socket del server, prima di poter ricevere connessioni, dovr\u00e0 porsi in modalit\u00e0 <code>listen</code></li> <li>il client, prima di poter inviare dati al server, dovr\u00e0 stabilire una <code>connessione</code> con il socket del server</li> <li>Una volta stabilita la connessione, i dati tra i due socket saranno veicolati tramite essa, con i metodi <code>sendall</code> e <code>recv</code></li> <li>I dati di passaggio nella connessione sono per forza di cose ordinati! (A questo ci pensa TCP... noi non dobbiamo fare nulla. Solo sapere...)</li> <li>Alla fine dello scambio di dati la connessione va chiusa con il metodo <code>close</code> da parte di entrambi i socket!!!</li> </ul> <p>Vediamo un esempio di codice che implementa un semplice client e un semplice server basati su TCP. Il client potr\u00e0 inviare qualsiasi messaggio vuole, mentre il server risponder\u00e0 comunque ok. Se il client invia la stringa close il server saluta con bye e chiude la connessione.</p> Simple Python TCP server<pre><code>import socket\n\nHOST = \"127.0.0.1\"  # Standard loopback interface address (localhost)\nPORT = 65432        # Port to listen on (non-privileged ports are &gt; 1023)\n\ntcp_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n\ntcp_socket.bind( (HOST, PORT) )\ntcp_socket.listen()\n\nprint(f\"listening on socket ({HOST}:{PORT})...\")\n\nconn, addr = tcp_socket.accept()\n\nif conn:\n    print(f\"Connected by {addr}\")\n\n    while True:\n        data = conn.recv(1024)\n        message = data.decode()\n        print(\"Received:\", message)\n        if message == \"close\":\n            conn.sendall( \"bye\".encode() )\n            break\n        conn.sendall( \"OK\".encode() )\n\nconn.close()\n</code></pre> <p>Qui sotto invece trovate il codice che implementa il client TCP.</p> Simple Python TCP client<pre><code>import socket\n\nHOST = \"127.0.0.1\"  # The server's hostname or IP address\nPORT = 65432  # The port used by the server\n\ntcp_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\ntcp_socket.connect( (HOST, PORT) )\n\nwhile True:\n    message = input(\"Message to send: \")\n\n    tcp_socket.sendall( message.encode() )\n    data = tcp_socket.recv(1024)\n    message = data.decode()\n    print(f\"Received: {data.decode()}\")\n\n    if message == \"bye\":\n        tcp_socket.close()\n        break\n</code></pre> <p> </p>"},{"location":"tutorials/20_tello/","title":"Tello SDK","text":"<p>Per affrontare questo tutorial sar\u00e0 necessario aver affrontato il tutorial su socket e network programming.</p> <p>Un <code>Software Development Kit</code> \u00e8 un insieme di strumenti (un Kit, appunto) che permette di sviluppare software relativo ad un tema specifico. Pu\u00f2 contenere un insieme di librerie specifiche per lo sviluppo, una documentazione specifica, un insieme di strumenti per sviluppare software e molto altro.</p> <p>Il <code>Tello SDK</code> \u00e8 sostanzialmente un documento che spiega come collegarsi al drone da remoto, come inviargli comandi e quali risposte aspettarsi da esso.</p> <p>Per adesso, non far\u00f2 altro che mettere un link al documento</p> <p>Buona lettura!!</p> <p> </p>"},{"location":"tutorials/30_pyserial/","title":"PySerial","text":"<p>Blah blah...</p> <p> </p>"}]}