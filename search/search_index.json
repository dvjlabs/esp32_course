{"config":{"lang":["it"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"MicroPython && ESP32","text":"<p>Un semplice corso per parlare di:</p> <ul> <li> <p>il microcontrollore ESP32: un dispositivo programmabile alla nostra portata</p> </li> <li> <p>L'interprete MicroPython: un interprete Python ridotto, adatto per i microcontrollori</p> </li> <li> <p>Thonny: il nostro editor Python preferito!!! Qui utilizzato (anche) per interagire con un microcontrollore</p> </li> <li> <p>sensori ed elettronica: vuoi implementare un semaforo? Una calcolatrice? Una stazione meteo? Un allarme? Dovrai far interagire alcuni sensori con il tuo microcontrollore e dovrai gestirli tramite il tuo codice. Sar\u00e0 divertente!!!</p> </li> </ul> <p>Poi... per il divertimento di tutti, allestiremo anche una sezione di tutorials, per (provare a) fare cose in autonomia!!</p> <p>Cominciamo!</p> <p>Il Corso! I Tutorials!</p> <p> </p>"},{"location":"corso/00_intro/","title":"Introduzione","text":"<p>Giusto due parole per introdurre:</p> <ul> <li>Il MicroControllore ESP32</li> <li>Le specifiche del dispositivo in dotazione alla scuola</li> <li>MicroPython</li> </ul> <p>Introduciamo i concetti in senso generale... se avete fretta e volete passare subito alla fase operativa... il prossimo capitolo \u00e8 per voi.</p> <p>Iniziamo!!</p>"},{"location":"corso/00_intro/#il-microcontrollore-esp32","title":"Il MicroControllore ESP32","text":"<p>ESP32 \u00e8 un microcontrollore a basso costo, con Wifi e bluetooth integrato, oltre che un'interfaccia programmabile per la gestione di vari sensori collegati ad esso.</p> <p>MicroControllore</p> <p>Un MicroControllore (MCU) \u00e8 un dispositivo elettronico integrato in un unico circuito, in grado di eseguire in maniera autosufficiente un determinato software.</p> <p>Si presenta come alternativa al MicroProcessore (CPU) che \u00e8 un dispositivo con maggiore potenza di calcolo, ma con la continua necessit\u00e0 di interfacciarsi con periferiche esterne, tipo RAM, ROM, etc.. per la selezione del software da eseguire.</p> <p>Un microcontrollore, una volta che vi viene caricato un software da eseguire, lo esegue all'infinito dal momento in cui viene acceso al momento in cui esso viene spento. \u00c8 dunque la soluzione ideale per la realizzazione di qualsiasi dispositivo elettronico: una calcolatrice, la macchina del caff\u00e8, una lavatrice moderna, la stampante 3D... sono tutti oggetti realizzati tramite MCU!</p> <p>Risulta dunque evidente quanto i MicroControllori rappresentino uno dei mattoni fondamentali dell'evoluzione dell'informatica e delle telecomunicazioni conosciuta con il nome di Internet of Things.</p> <p></p>"},{"location":"corso/00_intro/#specifiche-tecniche","title":"Specifiche tecniche","text":"<p>Attenzione!</p> <p>Le informazioni qui sotto sono roba da nerd... leggetele con il rischio di appassionarvi a certe precisazioni!!</p> <p>La ESP32 in dotazione a scuola \u00e8 una <code>ESP32-WROOM-32 dLOIN32</code> (se avete gli occhi buoni... lo potrete leggere sul dispositivo stesso):</p> <ul> <li>Deve essere alimentato a 3.3 Volt</li> <li>Consuma fino a 500mA</li> <li>Il controllore ESP32-WROOM-32, \u00e8 un dual-core a 32 bit Xtensa LX6</li> <li>Ha una frequenza di 240 Mhz</li> <li>La memoria predefinita \u00e8 una ROM di 32 Mb a 40 Mhz</li> <li>Il WiFi supporta i protocolli 802.11 b/g/n, fino a 150 Mbps</li> <li>Ha Bluetooth 4.2 BR/EDR e BLE</li> <li>Ricevitore NZIF</li> <li>Supporta le seguenti cifrature: WAPI, WEP, TKIP, AES, SHA-2, RSA, ECC</li> <li>Input analogici (ADC): 12, a 12-bit ognuna</li> <li>Output analogici (DAC): 2, a 8-bit ognuna</li> <li>Interfacce: GPIO, UART, I2C, I2S, SPI, PWM, Touch, Ethernet MAC, SDcard, SDIO, IrDA</li> <li>UART baud rate: fino a 5MBit/s</li> <li>Output LED programmabile: al GPIO 5</li> <li>Supporta: ARDUINO, NodeMCU, MicroPython, ESP-IDF</li> </ul>"},{"location":"corso/00_intro/#micropython","title":"MicroPython","text":"<p>MicroPython \u00e8 una implementazione del linguaggio Python progettata per essere eseguita sui microcontrollori. Uno degli obiettivi del progetto \u00e8 quello di ricercare la miglior compatibilit\u00e0 possibile con il Python normale, per semplificare l'apprendimento e la realizzazione di software che colleghi i due mondi <code>desktop</code> e <code>sistemi embedded</code>.</p> <p>Il sito ufficiale di MicroPython \u00e8 (incredibilmente): https://micropython.org (sotto, uno screenshot)</p> <p></p> <p>Poich\u00e9 l'interprete va eseguito direttamente sul microcontrollore, va scaricato dal sito l'interprete adatto e installato su di esso.  Il prossimo capitolo spiega proprio questo!</p> <p>Domanda</p> <p>A proposito... sapete qual \u00e8 l'editor Python pi\u00f9 semplice ed adatto per la programmazione di microcontrollori basati su MicroPython??</p> <p>Se avete risposto Thonny, avete dato la risposta esatta!!!</p> <p> </p>"},{"location":"corso/01_prime_operazioni/","title":"Prime Operazioni","text":"<p>In questo capitolo installeremo il firmware MicroPython su ESP32 e faremo un primo test di funzionamento. L'obiettivo di questo capitolo \u00e8 essere operativi... le spiegazioni sul codice (Micro)Python e il dispositivo ESP32... arrivano dopo!</p>"},{"location":"corso/01_prime_operazioni/#installazione-firmware","title":"Installazione Firmware","text":"<p>Per caricare il firmware MicroPython Thonny offre una comodissima interfaccia, che ci permette di scaricarlo e installarlo automaticamente!!!</p> <ul> <li>Aprite <code>Thonny</code></li> <li>Dal men\u00f9 <code>ESEGUI</code>, seleziona <code>CONFIGURA L'INTERPRETE</code></li> <li>Seleziona <code>MicroPython (ESP32)</code> (vedi figura sotto)</li> </ul> <p></p> <p></p> <p></p> <p>La giusta porta COM</p> <p>Come vedete in figura, la MCU utilizza una porta COM supportata dal driver Silicon Labs CP210x USB to UART Bridge.</p> <p>Se nel tuo computer manca... chiedi al prof!!!</p> <p></p> <ul> <li>Adesso selezionate <code>Installa o Aggiorna MicroPython</code></li> <li> <p>Si aprir\u00e0 la finestra qui sotto. Vanno selezionate:</p> <ul> <li>la porta su cui \u00e8 collegata il microcontrollore ESP32</li> <li>La famiglia della MCU (ESP32)</li> <li>La variante (EspressIf - ESP32 / WROOM)</li> <li>la versione (dovrebbe apparire automaticamente l'ultima installabile)</li> </ul> </li> <li> <p>Poi clicca <code>installa</code></p> </li> </ul> <p></p> <p></p> <p></p> <p>... attendi fiducioso un minutino buono...</p> <p>Al termine della procedura dovrebbe apparire l'interprete MicroPython nella shell di Thonny</p> <p></p> <p></p> <p></p> <p>Ecco fatto!</p> <p>Siamo pronti per il primo esempio!</p>"},{"location":"corso/01_prime_operazioni/#primo-programma","title":"Primo programma","text":"<p>Di solito i primi programmi che si scrivono testando un nuovo ambiente sono i famigerati HelloWorld! In questo caso particolare invece, andremo ad accendere e spegnere (ad intervalli programmati) il led fisico (detto, appunto, programmabile) disponibile nell'ESP32.</p> <p>Il programma scriver\u00e0 inoltre su <code>REPL</code> una notifica del tipo \"LED Acceso\" o \"LED Spento\".</p> <p>REPL</p> <p><code>Read Eval Print Loop</code> \u00e8 una caratteristica tipica dei linguaggi interpretati che forniscono accesso all'interprete da console. In Python REPL viene identificato dai 3 maggiori <code>&gt;&gt;&gt;</code> ed \u00e8 effettivamente un punto di accesso all'interprete stesso.</p> <p>Tu scrivi un comando, lui lo legge (Read), lo valuta (Eval), visualizza un output come risultato della sua valutazione (Print) e infine ripresenta il prompt iniziale <code>&gt;&gt;&gt;</code> (Loop).</p> <p>Il programma ci serve come esempio per prendere confidenza con i mondi MicroPython ed ESP32: non \u00e8 importante adesso quello che fa il programma, ma riuscire a capire tutte le operazioni da svolgere. Per questo ho deciso di dividere le operazioni in step successivi. Andiamo!!</p> <p>Step 0</p> <p>Se non lo hai gi\u00e0 fatto, connetti il tuo ESP32 al computer, apri Thonny e cambia l'interprete Python a <code>MicroPython (ESP32)</code>.</p> <p>Step 1</p> <p>Copia su Thonny il seguente codice:</p> <pre><code>from machine import Pin\nimport time\n\n# Il pin 5 \u00e8 quello del LED programmabile\n# Ricordate?\nled = Pin(5, Pin.OUT)\nled.off()\n\nwhile True:\n    led.on()\n    print(\"LED Acceso\")\n    time.sleep(1)\n\n    led.off()\n    print(\"LED Spento\")\n    time.sleep(1)\n</code></pre> <p>Step 2</p> <p>Adesso salva il file come <code>led_test.py</code> dentro la memoria dell'ESP32. Per farlo:</p> <ul> <li>clicca SALVA</li> <li>Dall'interfaccia seleziona Dispositivo MicroPython</li> </ul> <p></p> <p></p> <p></p> <ul> <li>Salva il file nella MCU con nome <code>led_test.py</code> o come preferisci.</li> </ul> <p>Step 3</p> <p>Esegui il codice, premendo <code>F5</code> oppure selezionando l'azione <code>Run current script</code>: dovresti vedere le scritte <code>LED Spento</code> e <code>LED Acceso</code> alternate di un secondo mentre il LED si accende e si spegne.</p> <p>Ecco fatto!</p>"},{"location":"corso/01_prime_operazioni/#bootpy","title":"boot.py","text":"<p>Sicuramente avrai notato che nel filesystem dell'ESP32 \u00e8 presente un file chiamato <code>boot.py</code>. Questo file viene eseguito automaticamente... al boot del dispositivo. Quindi il poco codice che va l\u00ec dentro pu\u00f2 servire per le prime indispensabili operazioni irrinunciabili:</p> <ul> <li>collegarsi ad una rete wifi,</li> <li>attivare il bluetooth,</li> <li>far partire webrepl (qualunque cosa esso sia)...</li> </ul> <p>Basta!</p> <p>Il boot \u00e8 l'operazione pi\u00f9 importante per un microcontrollore che, dopo questa fase, si mette in uno stato di ripetizione infinita del codice che dovr\u00e0 eseguire finch\u00e9 il dispositivo \u00e8 acceso.</p> <p>Attenti a quello che scrivete nel file \"boot.py\"! Qualunque errore l\u00ec si tradurra in problemi all'avvio e in grandi difficolt\u00e0 per la risoluzione! Qualunque codice che ci copiate va testato ed eseguito prima su un altro file e poi spostato l\u00ec dentro.</p>"},{"location":"corso/01_prime_operazioni/#mainpy","title":"main.py","text":"<p>Se volete fare in modo che, appena finite le operazioni di boot, il microcontrollore cominci ad eseguire un codice qualunque, il file ove dovete salvarlo si chiama <code>main.py</code>.</p> <p>Il codice l\u00ec dentro:</p> <ul> <li>sar\u00e0 eseguito subito dopo il boot, ovvero quando il dispositivo \u00e8 gi\u00e0 pienamente funzionante.</li> <li>sar\u00e0 facile da stoppare con un semplice CTRL + C oppure con lo stop del micropython.</li> <li>blah blah (\u00e8 meglio e basta! Se devi far partire codice all'avvio del dispositivo, mettilo in un file main.py)</li> </ul> <p> </p>"},{"location":"corso/02_micropython/","title":"MicroPython","text":"<p>Come abbiamo gi\u00e0 detto, MicroPython \u00e8 un interprete progettato appositamente per i microcontrollori e che cerca di emulare le funzionalit\u00e0 base di Python. Sostanzialmente sono implementati due gruppi di funzionalit\u00e0:</p> <ul> <li>alcune delle librerie della Python Standard Library</li> <li>alcune funzionalit\u00e0 specifiche per i microcontrollori.</li> </ul> <p>Documentazione Ufficiale</p> <p>Il progetto MicroPython espone nel suo sito web la documentazione ufficiale di riferimento per il progetto MicroPython.</p> <p>Se volete curiosare... fate pure. Lo spirito con cui ho messo i link mirati qui sotto \u00e8 invece quello di consultare una documentazione specifica secondo necessit\u00e0.</p>"},{"location":"corso/02_micropython/#funzionalita-micro-ified","title":"Funzionalit\u00e0 micro-ified","text":"<p>I moduli elencati qui, sono moduli presenti nella <code>Python Standard Library</code>, che sono stati reimplementati per funzionare in maniera analoga identica in MicroPython.</p> <p>L'elenco completo dei moduli reimplementati lo trovate al seguente link:</p> <p>In particolare, a noi potrebbero tornare utili:</p> <ul> <li><code>math</code>, per operazioni matematiche</li> <li><code>random</code>, per generare numeri pseudo-casuali</li> <li><code>socket</code>, per funzionalit\u00e0 di rete basate sul livello di trasporto</li> <li><code>time</code>, per funzioni relative a data e ora (e la utilissima funzione <code>sleep()</code>)</li> </ul>"},{"location":"corso/02_micropython/#funzionalita-specifiche","title":"Funzionalit\u00e0 specifiche","text":"<p>I moduli elencati qui sono moduli specifici per MicroPython: questi moduli nella <code>Python Standard Library</code> non ci sono!</p> <p>Tutte le funzionalit\u00e0 implementate sono documentate al seguente link.</p> <p>In particolare, mi piace mettere in eveidenza i seguenti moduli, che sicuramente prima o poi ci ritorneranno utili:</p> <p>modulo <code>machine</code> - (documentazione)  Funzioni collegate all'hardware della MCU. Permette di gestire ogni componente hardware del microcontrollore.</p> <p>modulo <code>esp32</code> (documentazione)  contiene funzionalit\u00e0 specifiche per il microcontrollore esp32</p> <p>modulo <code>micropython</code> - (documentazione)  Accesso e controllo delle librerie interne di MicroPython. Pu\u00f2 essere utilizzato per implementare funzionalit\u00e0 aggiuntive.</p> <p>modulo <code>network</code> - (documentazione)  Modulo per la configurazione della rete. Collegamento del dispositivo alla rete Wifi, del suo indirizzamento e routing.</p> <p>modulo <code>bluetooth</code> - (documentazione)  Libreria Bluetooth di basso livello. Serve (ovviamente) per connettere la MCU tramite bluetooth</p> <p>I moduli <code>network</code> e <code>bluetooth</code> saranno trattati nel capitolo relativo al networking. Qui sotto proveremo a parlare dei moduli di base.</p> <p> </p>"},{"location":"corso/03_GPIO/","title":"GPIO","text":"<p>GPIO \u00e8 l'acronimo di <code>General Purpose Input Output</code> ed \u00e8 il concetto con cui si descrive l'interazione della MCU con tutto l'hardware che \u00e8 possibile collegare ad essa. Tipicamente, il collegamento avviene per mezzo dei <code>pin</code> che contornano la MCU. </p> <pre><code>Ma quale corrispondenza c'\u00e8 fra i vari pin e il codice che possiamo scrivere con MicroPython??\n</code></pre> <p>La risposta \u00e8 semplice ma un p\u00f2 articolata. </p> <p>Prima di tutto il sistema di pin ha un ruolo e una numerazione, come vediamo nella figura sottostante</p> <p></p> <p></p> <p></p> <p>Con un pochino di esperienza capiremo al volo quali pin utilizzare e come... per adesso osserviamo pezzo per pezzo lo schema:</p> <ul> <li> <p>le scritte viola sono tutte del tipo <code>GPIOXX</code> dove <code>XX</code> \u00e8 il numero identificativo del pin in questione: quello \u00e8 l'informazione che   ci serve per interagire con il dispositivo eventualmente collegato a quel pin fisico.</p> </li> <li> <p>le scritte rosse sono solo <code>3.3v</code> oppure <code>5v</code>. Indicano il voltaggio che si pu\u00f2 ottenere collegando un dispositivo a uno di quei pin.   Ovviamente serve per alimentarlo </p> </li> <li> <p>le scritte nere <code>GND</code> (ground) indicano i pin di collegamento a terra di un circuito elettrico.</p> </li> <li> <p>le scritte grigie <code>Input Only</code> indicano che quei pin sono di collegamento unilaterale per la lettura dei dati dal dispositivo elettronico alla MCU.</p> </li> <li> <p>le linee nere che collegano le scritte ai pin hanno in alcune di esse una pulsazione! I pin che ce l'hanno supportano il <code>Pulse Width Modulation</code>,   di cui parleremo a breve.</p> </li> </ul> <p>Per adesso basta! Con questi siamo gi\u00e0 sufficientemente operativi.</p> <p>Negli esempi di codice che seguono andremo a ragionare su un sensore, un attuatore, un... hardware da collegare in qualche modo alla nostra MCU, con cui interfacciarsi osservando questa immagine di riferimento e utilizzando la libreria MicroPython necessaria.</p> <p>Proviamo!!!</p> <p> </p>"},{"location":"corso/10_sensori/","title":"Sensori e ESP32","text":"<p>In questo capitolo andremo semplicemente a definire gli oggetti di base tramite i quali costruire i nostri progetti hardware,  governati da un ESP32 e controllati tramite codice MicroPython.</p> <p>Introduciamoli:</p>"},{"location":"corso/10_sensori/#breadboard","title":"BreadBoard","text":"<p>Una BreadBoard \u00e8 un componente fisico utilizzato per i circuiti di test e per la didattica. Ha una struttura molto semplice, comprensibile al volo semplicemente osservando l'immagine seguente:</p> <p></p> <p>Nel dubbio, riassumo quanto bisognerebbe dedurre al volo:</p> <ul> <li>la breadboard \u00e8 spaccata in due a met\u00e0: la parte sopra NON comunica con la parte sotto</li> <li>le colonne evidenziate in verde hanno ognuna tutti i fori collegati fra loro: tipicamente servono per i collegamenti elettrici</li> <li>le righe rosse e blu sono anch'esse ognuna tutte collegate fra loro: tipicamente servono per l'alimentazione dei circuiti</li> </ul>"},{"location":"corso/10_sensori/#resistenze","title":"Resistenze","text":"<p>Una resistenza \u00e8 un componente elettrico passivo che si oppone al passaggio di corrente elettrica. Quanto forte sia la sua capacit\u00e0 di opposizione  dipende dalla quantit\u00e0 di corrente che passa e dalla sua... resistenza. </p> <p></p> <p>La capacit\u00e0 di opposizione si misura in Ohm e il rapporto fra le grandezze in gioco \u00e8 descritto dalla Prima legge di Ohm:</p> <p><code>V = R * I</code></p> <p>dove:</p> <ul> <li><code>V</code> rappresenta la differenza di potenziale fra le due estremit\u00e0 della resistenza e si misura in <code>Volt (V)</code></li> <li><code>R</code> rappresenta la resistenza del componente elettrico al passaggio di corrente e si misura in <code>Ohm (\u03a9)</code></li> <li><code>I</code> rappresenta la quantit\u00e0 di corrente in attraversamento e si misura in <code>Ampere (A)</code></li> </ul> <p>I colori delle resistenze</p> <p>Come avrete notato, le resistenze hanno dei cerchi colorati che le decorano, che servono a capire con quale resistenza abbiamo a che fare.</p> <p>Per capire come funzionano... provare a ragionare sull'immagine seguente:</p> <p></p> <p> </p>"},{"location":"corso/11_led_ledbar/","title":"Led(s)","text":"<p>Un LED \u00e8 un componente elettronico che funziona solo quando la corrente scorre nel verso giusto. Tipicamente ha due poli: il polo positivo nel pin pi\u00f9 lungo (catodo) e il polo negativo nel pin pi\u00f9 corto (anodo).</p> <p></p> <p>I led lavorano ad una corrente di attraversamento compresa fra 1.9V e 3.3V. Se la corrente supera questo voltaggio, il LED si dannegger\u00e0 e magari... prender\u00e0 fuoco. </p>"},{"location":"corso/11_led_ledbar/#led-integrato","title":"LED Integrato","text":"<p>Come abbiamo (probabilmente) gi\u00e0 anticipato, la nostra MCU (il microcontrollore, l'ESP32) contiene un led integrato in essa e collegato direttamente al Pin fisico numero 5.</p> <p>Per farlo funzionare sar\u00e0 necessario semplicemente eseguire un codice del genere:</p> Led integrato lampeggiante<pre><code>from machine import Pin\nimport time\n\n# Il pin 5 \u00e8 quello del LED programmabile\n# Se collegate un LED fisico ad un GPIO, modificate il numero qui sotto!\nled = Pin(5, Pin.OUT)\nled.off()\n\nwhile True:\n    led.on()\n    print(\"LED Acceso\")\n    time.sleep(1)\n\n    led.off()\n    print(\"LED Spento\")\n    time.sleep(1)\n</code></pre> <p>Non c'\u00e8 molto altro da aggiungere </p>"},{"location":"corso/11_led_ledbar/#led-fisico","title":"LED Fisico","text":"<p>In questo progetto dobbiamo costruire un circuito per collegare un led all'ESP32. Il circuito dovr\u00e0 realizzare uno schema tipo il seguente:</p> <p></p> <p>A seconda del PIN scelto per il collegamento fisico del LED, modificate il codice dell'esempio precedente per far accendere il led che avete appena collegato.</p>"},{"location":"corso/11_led_ledbar/#led-bar","title":"LED Bar","text":"<p>La barra dei LED \u00e8 un semplice componente in cui sono integrati ben 10 LED!!! Il collegamento fisico al microcontrollore \u00e8 una semplice iterazione del circuito del LED:</p> <p></p> <p>Adesso tramite codice andiamo a fornire un comportamento al nostro progetto: Facciamo in modo che ogni secondo la barra si riempa sempre pi\u00f9 e poi inizi a svuotarsi. Ecco il codice:</p> ledbar che si carica e scarica<pre><code>from machine import Pin\nimport time\n\n# I 10 pin, in ordine di connessione alla ledbar\npins=[22,21,19,23,18,17,16,4,2,15]\n\nacceso = True\nwhile True:\n    for p in pins:\n        led = Pin( p, Pin.OUT)\n        led.value( acceso )\n        time.sleep_ms(500)\n\n    # rovescia l'ordine dei pin\n    pins.reverse()\n\n    # inverti vero/falso\n    acceso = not acceso\n</code></pre>"},{"location":"corso/11_led_ledbar/#esercizi","title":"Esercizi","text":"<p>Dal vivo o con il simulatore!</p> <p>Ognuno dei seguenti esercizi pu\u00f2 essere svolto indifferentemente dal vivo, ovvero con ESP32 e sensori reali, oppure con il simulatore wokwi (ad esempio come compiti per casa)!!!</p> <p></p> <p>Luci della Polizia!</p> <p>Due led, uno rosso e uno blu. Si accendono alternativamente ogni decimo di secondo (regolate il tempo necessario, se un decimo \u00e8 poco o troppo!) Quando la luce rossa si accende, la blu si spegne e viceversa</p> <p></p> <p>Semaforo</p> <p>Tre led: verde, giallo, rosso. Implementazione di un semaforo. All'inizio la luce gialla lampeggia (accesa.. spenta.. accesa.. spenta). Poi tutto un tratto (scegliete voi quanto) parte il semaforo! Prima la luce rossa per due secondi, poi la luce verde per 4 secondi, la luce gialla per 1 secondo. Poi rosso e si ricomincia!</p> <p></p> <p>LED...Bar</p> <p>Una ledbar collegata all'esp32. La barra inizia da spenta e poi inizia il caricamento accendendo prima un led, poi due, poi tre... e cos\u00ec via ogni secondo. Quando la barra \u00e8 piena rimane accesa per due secondi, poi si spegne completamente per un secondo, poi si riaccende completamente per due secondi. A questo punto inizia a scaricarsi. Ogni secondo si spegne un led fino a che la barra non sia completamente spenta. A questo punto il programma termina.</p> <p> </p>"},{"location":"corso/12_buttons/","title":"Buttons","text":"<p>In questo capitolo andremo a provare alcuni esperimenti in cui costruiremo progetti hardware basati sui pulsanti e i led, governati da un ESP32 e controllati tramite codice MicroPython.</p> <p>I pulsanti hardware hanno due caratteristiche fisiche che vanno sempre considerate quando se ne inserisce uno in un circuito:</p> <ul> <li> <p>floating inputs: all'inizio l'ESP32 \u00e8 confuso perch\u00e9 non sa se lo stato iniziale del pulsante \u00e8 cliccato oppure no. Questo problema si pu\u00f2 risolvere con una resistenza di <code>pull-up</code> o di <code>pull-down</code>.</p> </li> <li> <p>chattering: se si clicca il pulsante molto rapidamente (ad esempio sparando in un gioco), l'ESP32 potrebbe pensare ad un'unica pressione prolungata. Questo problema si pu\u00f2 risolvere con tecniche di <code>debouncing</code>.</p> </li> </ul> <p>Vediamo come \u00e8 fatto internamente un pulsante:</p> <p></p> <p>E vediamo in quali modi \u00e8 possibile collegarlo al nostro ESP32:</p> <p></p> <p>In qualunque dei 4 modi indicati sopra, tutto il circuito passer\u00e0 sempre per il pulsante, che avr\u00e0 la possibilit\u00e0 di aprirlo o chiuderlo.</p> <p>Capito che servono due collegamenti, ci sono due modi il cui il pulsante pu\u00f2 essere collegato al circuito:</p> <ol> <li>in modalit\u00e0 <code>pull-down</code>, con una estremit\u00e0 connessa al <code>GPIO</code>, l'altra alla tensione di <code>3.3V</code>: in questo caso, quando il pulsante \u00e8 premuto il valore \u00e8 <code>HIGH</code>, altrimenti \u00e8 <code>LOW</code>.</li> <li>in modalit\u00e0 <code>pull-up</code>, con una estremit\u00e0 connessa al <code>GPIO</code>, l'altra al <code>GND</code>: in questo caso, quando il pulsante \u00e8 premuto il valore \u00e8 <code>LOW</code>, altrimenti \u00e8 <code>HIGH</code>.</li> </ol>"},{"location":"corso/12_buttons/#gestione-debouncing","title":"Gestione debouncing","text":"<p>Quando si preme un pulsante fisico, il circuito si apre e si chiude decine o centinaia di volte. Questo fenomeno \u00e8 chiamato bouncing. Ci\u00f2 accade a causa della natura meccanica dei pulsanti: quando i contatti metallici si uniscono, c'\u00e8 un breve periodo in cui il contatto non \u00e8 perfetto, il che causa una serie di rapide transizioni di apertura/chiusura.</p> <p>Il pulsante del simulatore</p> <p>Ovviamente, il pulsante del simulatore non ha problemi di contatti fisici, ma \u00e8 in grado di simularli impostando la variabile <code>Bounce</code> del pulsante:</p> <ul> <li>Se la imposti a <code>True</code>, il simulatore creer\u00e0 un centinaio di segnali aperto/chiuso ad ogni pressione del pulsante</li> <li>Se la imposti a <code>False</code>, il simulatore creer\u00e0 una singola coppia di segniali aperto/chiuso per ogni pressione.</li> </ul> <p>Il seguente codice presenta una semplice tecnica di debouncing software. Permette di tenere traccia delle pressioni utente di un pulsante.</p> debouncing software<pre><code># Se sei nel simulatore, imposta a OFF il Debounce del pulsante\nfrom machine import Pin\n\n# immaginiamo di gestire un pulsante collegato al pin 19 e al GND\n# impostato in modalit\u00e0 PULL_UP\nbutton = Pin(19, Pin.IN,Pin.PULL_UP)\n\nbuttonValue = button.value()\nprint(\"valore iniziale del pulsante: \", buttonValue)\n\n\nwhile True:\n    actualValue = button.value()\n    if buttonValue == actualValue:\n        continue\n\n    if actualValue == False:\n        print(\"hai cliccato il pulsante...\")\n\n    buttonValue = actualValue\n</code></pre>"},{"location":"corso/12_buttons/#esempi-con-i-pulsanti","title":"Esempi con i pulsanti","text":"<p>In questo progetto di prova abbiamo un pulsante collegato ad un LED nel nostro circuito. Incredibilmente... quando si clicca il pulsante dovrebbe accendersi la luce!!!</p> <p>Per ottenere questo effetto vogliamo collegare il pulsante in modalit\u00e0 PULL_DOWN e reagire quando questo viene premuto. Vediamo lo schema elettrico del progetto:</p> <p></p> <p>Quello che manca \u00e8 il codice di funzionamento. Eccolo:</p> <pre><code>from machine import Pin\n\n\nled = Pin(16, Pin.OUT)\nbutton = Pin(25, Pin.IN,Pin.PULL_UP)\n\nwhile True:\n    if button.value():\n        led.on()\n    else:\n        led.off()\n</code></pre>"},{"location":"corso/12_buttons/#esercizi","title":"Esercizi","text":"<p>Button LED...Bar</p> <p>Progetto contenente un pulsante e una barra dei led. Quando si clicca il pulsante, parte il caricamento della barra, che poi si scaricher\u00e0 quando \u00e8 tutta piena.</p> <p>Difficolt\u00e0 ulteriore: quando si clicca di nuovo il pulsante il caricamento si interrompe.</p> <p></p> <p> </p>"},{"location":"corso/20_analog_pwm/","title":"Analog &amp;&amp; PWM","text":"<p>In questa sezione cercheremo di capire la (semplice) differenza fra segnali digitali e analogici e come essi possano essere realizzati e gestiti nelle nostre composizioni.</p> <p>Un segnale analogico \u00e8 un segnale continuo nel tempo e nella variazione di valore, mentre un segnale digitale \u00e8 un segnale discreto nel tempo e nella variazione di valore.</p> <p>La figura spiega molto chiaramente il concetto espresso:</p> <p></p> <p>In informatica ed elettronica si utilizzano molto spesso i segnali digitali binari identificati con 0 e 1, mentre ovviamente i segnali analogici hanno un range ben definito (ad esempio, fra 0 e A, per qualche A positivo e neanche troppo grande). Ovviamente esiste praticamente sempre un sistema di conversione dei segnali da digitale ad analogico e viceversa.</p>"},{"location":"corso/20_analog_pwm/#pulse-width-modulation","title":"Pulse Width Modulation","text":"<p>PWM \u00e8 una tecnologia che permette di utilizzare segnali digitali per controllare circuiti analogici. L\u2019idea \u00e8 quella di alternare per un certo periodo i segnali digitali 0 e 1, calcolando la percentuale di tempo in cui il segnale sta a 1: quell\u2019informazione \u00e8 detta duty cycle.</p> <p>\u00c8 chiaro che PWM non \u00e8 una reale trasformazione di un segnale da digitale ad analogico, ma che calcolando l\u2019energia trasportata nel periodo di pulsazione si riesce ad approssimare con efficacia la quantit\u00e0 analogica da rappresentare.</p> <p></p> <p></p> <p></p> <p>Esistono dispositivi hardware (a costi accessibili) in grado di implementare un grado di accuratezza fino a 10 bit, che significa distinguere fino a 1024 valori analogici diversi.</p> <p>L\u2019implementazione di PWM dell'ESP32 ha 8 canali separati, ognuno dei quali pu\u00f2 gestire la frequenza in maniera indipendente, cio\u00e8 ognuno dei Pin di output PWM sono configurabili a frequenze diverse.</p> <p>Per comprenderne il funzionamento, facciamo un esempio con il led programmabile (GPIO 5):</p> <pre><code>from machine import Pin,PWM\nimport time\n\n# il led da gestire\nledPin = Pin(5, Pin.OUT)\n\n# tempo di attesa in millisecondi\n# varia questo numero per aumentare/diminuire la velocit\u00e0 di illuminazione del led\nms_time = 100\n\n# l'oggetto per la gestione del PWM\n# richiede:\n# - l'oggetto fisico su cui applicare il PWM (nel nostro caso, il led)\n# - la frequenza in ms del pwm\npwm = PWM( ledPin, 10000)\n\nwhile True:\n\n    # qui si carica...\n    for i in range(0,1023):\n        pwm.duty(i)\n        time.sleep_ms(ms_time)\n\n    # ...qui si scarica.\n    for i in range(0,1023):\n        pwm.duty(1023 - i)\n        time.sleep_ms(ms_time)\n\n# ripulisce l'oggetto del PWM\npwm.deinit()\n</code></pre>"},{"location":"corso/20_analog_pwm/#breathing-led","title":"Breathing LED","text":"<p>Con \"Breathing LED\" si intende un LED che cambia la sua intensit\u00e0 luminosa in maniera continua e controllata. Il materiale necessario e schema circuitale sono gli stessi di qualunque progetto con un LED! In questo caso per\u00f2 bisogna essere sicuri che il pin di collegamento del LED supporti il PWM (cio\u00e8 che abbia la caratteristica \"ondina\" nello schema del GPIO).</p> <p>Il codice di gestione comprende il concetto di PWM cos\u00ec come la gestione del LED</p> <pre><code>from machine import Pin,PWM\nimport time\n\n# un pin che supporti output e PWM\npin = Pin(18, Pin.OUT)\n\npwm = PWM( pin,10000)\n\n# provate a modificare questo valore per osservare il cambio di comportamento\nsleep_time = 1\n\nwhile True:\n    for i in range(0,1023):\n        pwm.duty(i)\n        time.sleep_ms( sleep_time )\n\n    for i in range(0,1023):\n        pwm.duty(1023-i)\n        time.sleep_ms( sleep_time )\n\npwm.deinit()\n</code></pre> <p> </p>"},{"location":"corso/21_led_rgb/","title":"RGB Led","text":"<p>Un led RGB non \u00e8 altro che un led in grado di generare 3 differenti colori. Attivando i tre colori insieme e mescolandoli opportunamente con tecniche PWM \u00e8 possibile sostanzialmente ottenere qualsiasi colore.</p> <p></p> <p>Come si evince dalla figura, il LED RGB presenta un pin per ogni colore fondamentale della sintesi RGB pi\u00f9 un pin comune.</p> <p>Il <code>common pin</code> pu\u00f2 essere:</p> <ul> <li> <p>un <code>anodo</code> (negativo). In questo caso va collegato alla tensione 3.3V. La sintesi dei colori \u00e8 negativa (ZERO \u00e8 spento, UNO \u00e8 nero, i colori sono rovesciati)</p> </li> <li> <p>un <code>catodo</code> (positivo). In questo caso va collegato al GND. La sintesi dei colori \u00e8 positiva (ZERO \u00e8 spento, UNO \u00e8 bianco)</p> </li> </ul> <p>Forse conviene leggersi la nota sulla sintesi dei colori...</p> <p>SINTESI ADDITIVA (RGB)</p> <p>La sintesi delle luci: se punti una luce rossa nello stesso punto di una luce verde, vedi una luce colore giallo!</p> <pre><code>I colori fondamentali di questa sintesi sono Rosso (Red), Verde (Green), Blu (Blue).\n\nLa somma dei 3 colori fondamentali fa il BIANCO!!!\n</code></pre> <p>Ogni colore fondamentale \"costa\" un byte, quindi ogni colore \"pesa\" 3 byte, ovvero sono rappresentabili 2 alla 24 colori diversi: circa 16 milioni di colori! Il web utilizza questa sintesi dei colori. La sua rappresentazione \u00e8 data dai 3 byte, tipicamente indicati con la sintassi esadecimale <code>#RRGGBB</code> Questa sintassi indica che i primi 2 numeri esadecimali rappresentano il byte che indica la quantit\u00e0 di rosso presente, i secondi la quantit\u00e0 di verde, gli ultimi la quantit\u00e0 di blu.</p> <pre><code>    Ad esempio:\n    #FF0000 rappresenta il rosso\n    #00FF00 rappresenta il verde\n    #0000FF rappresenta il blu\n    #000000 \u00e8 il nero\n    #FFFFFF \u00e8 il bianco\n    #888888 \u00e8 un grigio\n    #ADADAD \u00e8 un grigio pi\u00f9 chiaro\n    #FF8888 \u00e8 un rosso chiaro\n    ...\n</code></pre> <p></p>"},{"location":"corso/21_led_rgb/#progetto-led-colorato","title":"Progetto: LED colorato","text":"<p>Nel nostro progetto andiamo a comporre un circuito con un unico LED RGB con il pin comune come catodo e quindi collegato al GND:</p> <p>Infine testiamo il seguente codice:</p> <pre><code>from machine import Pin,PWM\nimport random\nimport time\n\npinR = Pin(19, Pin.OUT)\npinG = Pin(2,  Pin.OUT)\npinB = Pin(15, Pin.OUT)\npwmR = PWM(pinR,10000)\npwmG = PWM(pinG,10000)\npwmB = PWM(pinB,10000)\n\ncolors = {\"red\":(1023,0,0), \"green\":(0,1023,0), \"blue\":(0,0,1023),\"white\":(1023,1023,1023) }\n\nwhile True:\n  for color in colors:\n    (r,g,b) = colors[color]\n    print(color)\n    pwmR.duty(r)\n    pwmG.duty(g)\n    pwmB.duty(b)\n    time.sleep(2)\n\npwmR.deinit()\npwmG.deinit()\npwmB.deinit()\n</code></pre>"},{"location":"corso/21_led_rgb/#esercizi","title":"Esercizi","text":"<p>Semaforo</p> <p>Implementare un semaforo con un unico LED RGB: ogni 3 secondi la luce passa in maniera continua  da verde a giallo, poi dopo altri 3 secondi da giallo a rosso e dopo altri 3 secondi da rosso a verde.</p> <p>E poi si ricomincia.</p> <p>Modificare il progetto in modo da poter decidere liberamente la durata delle luci verde, gialla, rossa.</p> <p></p> <p>Luci Alternate</p> <p>Implementare un progetto con 2 luci LED semplici. Le luci si alternano in senso continuo, in modo che la somma dei 2 duty cycle sia sempre 100. Modificare il codice per fare in modo che ogni luce sia completamente accesa (e l\u2019altra completamente spenta) per 3 secondi.</p> <p></p> <p>LED e Pulsante</p> <p>Implementare un progetto con un pulsante e un LED. Il led \u00e8 inizialmente spento. Quando si clicca il pulsante, il led inizia ad accendersi fino ad essere completamente acceso, poi inizia a spegnersi e continua ad alternare le due fasi in maniera continua.</p> <p>Quando si clicca di nuovo il pulsante, l\u2019avanzamento si interrompe e la luce rimane ferma. Quando si clicca di nuovo la luce riparte dal punto in cui si era precedentemente fermata.</p> <p></p> <p>Caricamento barra dei LED</p> <p>Implementare un progetto con una barra dei led. Ogni led si accende dopo un secondo e quando la barra \u00e8 piena dopo un secondo ricomincia a spegnersi.</p> <p> </p>"},{"location":"corso/22_buzzer/","title":"Sensori: i buzzers","text":"<p>I buzzer sono dei componenti sonori utilizzati nei pi\u00f9 disparati dispositivi elettrici ed elettronici: nei calcolatori, negli orologi,  negli allarmi, nei cruscotti delle auto, nei campanelli delle case fino ai... cellulari!</p> <p>I tipi di buzzer che noi utilizzeremo sono molto semplici (e non troppo rumorosi) ma concettualmente identici a tutti gli altri,  diversi magari per dimensione e/o rumorosit\u00e0.</p> <p>I buzzer sono di due tipi:</p> <ol> <li>buzzer attivi: sono quelli che hanno un oscillatore al loro interno e che per suonare necessitano solo di essere alimentati</li> <li>buzzer passivi: necessitano di un oscillatore esterno (nel nostro caso un PWM) per emettere un suono.</li> </ol> <p></p> <p>I buzzer attivi sono semplicissimi da usare, ma tipicamente sono in grado di fare solo uno specifico suono. I buzzer passivi necessitano di un intero circuito per funzionare, ma di contro possono essere regolati per emettere suoni a frequenze differenti.</p> <p>Se tutto fosse cos\u00ec facile... staremmo gi\u00e0 cominciando a divertirci con i progetti di oggi...ma purtroppo c\u2019\u00e8 un altro problema da risolvere:  i buzzer per fnuzionare necessitano di una quantit\u00e0 di corrente decisamente superiore a quella erogata dai nostri dispositivi!</p> <p>Per risolvere questa ulteriore problematica, dobbiamo utilizzare un transistor.</p> <p></p> <p>Un transistor \u00e8 un dispositivo elettronico in grado di funzionare da interruttore o da amplificatore.  Come si intuisce dalle figure, un transistor \u00e8 un oggetto elettronico con tre collegamenti verso l\u2019esterno:</p> <ol> <li>Base (B): da dove solitamente arrivano i segnali di comando</li> <li>Emettitore (E): da dove solitamente escono i segnali elaborati dal transistor</li> <li>Collettore (C): da dove solitamente arriva la corrente</li> </ol> <p>Neanche a dirlo, nel nostro kit sono disponibili ben due tipologie di transistor:</p> <ul> <li>transistor NPN, o transistor negativo</li> <li>transistor PNP, o transistor positivo</li> </ul> <p>La differenza fondamentale fra i due tipi sta nel fatto che nel transistor NPN la corrente positiva va collegata al collettore C,  ottenendo in uscita una corrente negativa, mentre nel transistor PNP la corrente positiva va collegata all\u2019emettitore E,  ottenendo in uscita una corrente positiva.</p> <p>Vabb\u00e8... speriamo di capire meglio le cose lavorando ai progetti...</p>"},{"location":"corso/22_buzzer/#buzzer-campanello","title":"Buzzer: campanello","text":"<p>Il campanello \u00e8 un progetto concettualmente semplice: quando tieni cliccato un pulsante, il campanello suona, quando lo lasci smette.</p> <p>Poich\u00e9 non abbiamo bisogno di variare toni e intensit\u00e0 del suono utilizzeremo un buzzer attivo, collegato ad un transistor NPN!  Ecco l\u2019elenco dei componenti:</p> <p></p> <p>Per quanto riguarda il circuito da implementare, ecco una immagine che lo descrive:</p> <p></p> <p>Selezionati i pin a cui collegare il buzzer e il pulsante, ecco il codice per l'implementazione del campanello:</p> <pre><code>from machine import Pin\n\nbutton = Pin(xxx,Pin.IN,Pin.PULL_UP)\nactiveBuzzer = Pin(yyy,Pin.OUT)\n\nactiveBuzzer.value(0)\n\nwhile True:\n    if not button.value():\n        activeBuzzer.value(1)\n    else:\n        activeBuzzer.value(0)\n</code></pre>"},{"location":"corso/22_buzzer/#buzzer-allarme","title":"Buzzer: allarme","text":"<p>Un allarme funziona in maniera analoga al progetto del campanello, ma ha il tipico suono ondulato che varia dall\u2019acuto al grave in maniera continua.  Per ottenere ci\u00f2, dovremo sostituire il buzzer attivo con uno passivo e implementare un PWM.</p> <p>Il progetto \u00e8 uguale al precedente, quello che cambia \u00e8 semplicemente il tipo di buzzer, il fatto che il pin di collegamento dovr\u00e0 per forsa supportare il PWN e il codice:</p> <pre><code>from machine import Pin,PWM\nimport math\nimport time\n\nPI = 3.14\n\nbutton = Pin(xxx,Pin.IN,Pin.PULL_UP)\n\npinB = Pin(yyy,Pin.OUT)\npassiveBuzzer = PWM( pinB, 2000)\n\ndef alert():\n\n\nwhile True:\n    if not button.value():\n        passiveBuzzer.init()\n\n        for x in range(0,36):\n            sinVal = math.sin(x*10*PI/180)\n            toneVal = 2000 + int(sinVal*500)\n            passiveBuzzer.freq(toneVal)\n            time.sleep_ms(10)   \n    else:\n        passiveBuzzer.deinit()\n\npassiveBuzzer.deinit()\n</code></pre>"},{"location":"corso/22_buzzer/#esercizi","title":"Esercizi","text":"<p>Sirena</p> <p>Implementare un progetto con un buzzer che suona per 2 secondi ogni 3 secondi.</p> <p>Luce e Suono</p> <p>Aggiungete una luce a LED al progetto precedente. Quando il buzzer suona, la luce deve accendersi.</p> <p>Barra dei led e suono</p> <p>Implementare un progetto con un buzzer passivo e una barra dei led. Quando il buzzer suona la barra dei led si accende.  Pi\u00f9 \u00e8 acuto il suono, pi\u00f9 la barra deve \"caricarsi\". La barra va spenta completamente solo quando il suono \u00e8 spento.</p> <p> </p>"},{"location":"corso/30_ADC/","title":"ADC","text":"<p>Un <code>ADC (Analog Digital Converter)</code> \u00e8 un circuito elettronico integrato utilizzato per convertire segnali analogici, come le tensioni, in forma digitale, come sequenza binaria. Questa operazione \u00e8 definita <code>campionamento</code>.</p> <p>L'ADC sui nostri ESP32 lavora ad una tensione di 3.3V e avendo un intervallo di input di 12 bit, presenta una risoluzione di 2<sup>12</sup> = 4096. Questo significa che, se con un numero reale puoi rappresentare qualunque valore fra 0 e 3.3, con il nostro ADC puoi solamente dividerlo in 4096 parti e rappresentare quelle frazioni della tensione grazie ad un numero binario.</p> <p>L'errore di misura che si introduce viene definito errore di quantizzazione.</p> <p></p> <p></p> <p></p> <p>L'ESP32 ha due ADC con 12 bit di accuratezza e un totale di 16 pin suddivisi fra i due ADC. Pi\u00f9 precisamente:</p> <p></p> <p>Attenzione</p> <p>Se si utilizza la scheda Wifi/Bluetooth integrata nell'ESP32, l'ADC2 e tutte le porte GPIO riconducili ad essa diventano inutilizzabili!!!</p> <p>Bisogna valutare bene il da farsi...</p> <p> </p>"},{"location":"corso/31_potentiometer/","title":"Potenziometri","text":"<p>Blah blah...</p> <p> </p>"},{"location":"corso/32_joystick/","title":"Joystick con ESP32","text":"<p>Un joystick \u00e8 un dispositivo di input utilizzato per controllare la  posizione di un cursore o di un oggetto su uno schermo,  soprattutto nei contesti di videogiochi, simulatori di volo o altre applicazioni interattive.  Si tratta di una leva o di un dispositivo simile che pu\u00f2 essere spostato in diverse direzioni per controllare il movimento di un cursore o di un'entit\u00e0 virtuale.</p> <p>I joystick possono avere varie forme e dimensioni,  ma in genere consistono in una leva che pu\u00f2 essere inclinata o spostata  in diverse direzioni.</p> <p>Esso fornisce al processore i segnali elettrici relativi alla posizione di due, l'asse X e l'asse Y.  Inoltre il joystick ha a disposizione anche l'asse Z  che ci servir\u00e0 per indicare la pressione o meno del joystick stesso.</p> <p></p> <p>In figura vediamo  i collegamenti elettrici che il nostro joystick richiede:</p> <ul> <li>Il collegamento al GND</li> <li>L'alimentazione a 5V (3.3V per il nostro joystick)</li> <li>L'asse X (valori da 0 a 4095)</li> <li>L'asse Y (valori da 0 a 4095)</li> <li>L'asse Z (valori da 0 a 1)</li> </ul> <p>I due segnali VRX e VRY (per gli assi X e Y) sono due segnali analogici che andranno  collegati direttamenti a due pin GPIO del componente ESP32 con  funzione ADC di convertitore Analogico-Digitale.</p>"},{"location":"corso/32_joystick/#codice","title":"Codice","text":"<p>I segnali elettrici collegati ai pin 13 e 14 vengono trasformati in segnali digitali (numeri) In pratica il valore di tensione in ingresso andr\u00e0 da un valore di 0V a un valore di 3.3V a seconda della posizione del  joystick. I corrispondenti valori digitali saranno 0 (per 0V) e 4095 (per 3.3V).</p> <p>Al pin 12 arriver\u00e0 in input o un valore basso (0 o LOW) o valore alto (1 o HIGH)  a seconda se il pin verr\u00e0 premuto o meno.</p> <p>Il codice \u00e8 sotto riportato.</p> <pre><code>from machine import ADC,Pin\nimport time\n\nxJoy = ADC(Pin(14)) # ADC sta per Analog-Conversion Converter\nyJoy = ADC(Pin(13))\nzJoy = Pin(12,Pin.IN,Pin.PULL_UP) # secondo l'asse Z, il joystick \u00e8 come un pulsante\n\n# impostano la dimensione di X,Y fra 0 e 4095\nxJoy.atten(ADC.ATTN_11DB)\nyJoy.atten(ADC.ATTN_11DB)\nxJoy.width(ADC.WIDTH_12BIT)\nyJoy.width(ADC.WIDTH_12BIT)\n\nwhile True:\n  x = xJoy.read()\n  y = yJoy.read()\n  z = zJoy.value()\n  print(\"X,Y,Z:\" , x , \",\" , y , \",\" , z )\n  time.sleep(1)\n</code></pre> <p>Quello che dovreste vedere sar\u00e0 qualcosa del genere:</p> <p></p>"},{"location":"corso/33_keypad/","title":"Keypad","text":"<p>Blah blah...</p> <p> </p>"},{"location":"corso/34_photoresistor/","title":"Photoresistori","text":"<p>Blah blah...</p> <p> </p>"},{"location":"corso/41_display/","title":"LCD Display(s)","text":""},{"location":"corso/42_IR/","title":"InfraRossi","text":"<p>Blah blah...</p> <p> </p>"},{"location":"corso/43_distance/","title":"Ultrasonic Distance Sensors","text":"<p>Blah blah...</p> <p> </p>"},{"location":"corso/44_DHT22/","title":"DHT22","text":"<p>Blah blah...</p> <p>The DHT driver is implemented in software and works on all pins:</p> <pre><code>from machine import Pin\nimport dht\n\n# questo in caso di sensore DHT11...\nd = dht.DHT11( Pin(4) )\nd.measure()\nd.temperature() # eg. 23 (\u00b0C)\nd.humidity()    # eg. 41 (% RH)\n\n# questo per il sensore DHT22...\nd = dht.DHT22( Pin(4) )\nd.measure()\nd.temperature() # eg. 23.6 (\u00b0C)\nd.humidity()    # eg. 41.3 (% RH)\n</code></pre> <p> </p>"},{"location":"corso/99_network/","title":"Connettere l'ESP32","text":"<p>In questa parte del corso andremo ad esplorare le potenzialit\u00e0 di rete presenti in ESP32! In particolare vedremo:</p> <ul> <li>come collegare l'ESP32 ad una rete WIFI</li> <li>come configurare l'ESP32 per creare una propria rete Wifi, a cui far connettere altri dispositivi.</li> <li>come gestire la connettivit\u00e0 Bluetooth, presente nel microcontrollore.</li> </ul> <p>Per la gestione del Wifi, si utilizza il modulo <code>network</code>, gi\u00e0 disponibile nel bundle MicroPython.</p> <p>Vediamo come</p>"},{"location":"corso/99_network/#funzionalita-del-modulo-network","title":"Funzionalit\u00e0 del modulo network","text":"<p>A volte visualizzare un p\u00f2 di codice ben commentato rende le cose pi\u00f9 semplici che tante parole...</p> <p></p> <p>IMPORTA il modulo network.</p> <pre><code>import network\n</code></pre> <p></p> <p>CREA l'oggetto interfaccia WLAN</p> <pre><code># l'opzione network.STA_IF crea una interfaccia in grado di connettersi ad una rete Wifi\nwlan = network.WLAN(network.STA_IF)\n\n# l'opzione network.AP_IF crea una interfaccia Access-Point\nwlan = network.WLAN(network.AP_IF)\n</code></pre> <p></p> <p>CONFIGURA, se necessario, l'oggetto interfaccia WLAN</p> <pre><code># Imposta il nome (si chiama SSID) della rete Wifi\nwlan.config(ssid='NomeReteWifi')\n# oppure\nwlan.config(ssid='NomeReteWifi' , security=3 , key=\"PasswordReteWifi\")\n</code></pre> <p></p> <p>ATTIVA l'interfaccia</p> <pre><code>wlan.active(True)\n</code></pre> <p></p> <p>ESEGUI le operazioni che ritieni necessarie. Qui ho elencato alcuni esempi in ordine sparso...</p> <pre><code># scansiona per individuare le reti Wifi disponibili \nnetwork_list = wlan.scan()\n\n# connette l'interfaccia WLAN alla rete Wifi SSID con chiave KEY\nwlan.connect('ssid', 'key')\n\n# controlla SE l'interfaccia \u00e8 connessa al Wifi.\n# Ritorna True/False\nwlan.isconnected()\n\n# visualizza la configurazione di rete.\n# Ritorna la tupla ( 'IP', 'SubnetMask' , 'gateway' , 'DNS')\nwlan.ifconfig()\n\n# configura la rete del dispositivo con le seguenti impostazioni: ( 'IP', 'SubnetMask' , 'gateway' , 'DNS')\nwlan.ifconfig( ('IP','SubnetMask','gateway','DNS') )\n</code></pre>"},{"location":"corso/99_network/#collegarsi-ad-una-rete-wifi","title":"Collegarsi ad una rete Wifi","text":"<p>Vediamo un paio di esempi di collegamento ad una rete wifi da parte del dispositivo ESP32. Nel primo andremo ad acquisire automaticamente le informazioni di rete, nel secondo andremo ad impostarle manualmente appena possibile.</p> <p></p> Connessione ad una rete WIFI ed indirizzamento tramite DHCP<pre><code>import network\nimport time\n\nwlan = network.WLAN(network.STA_IF)\nwlan.active(True)\n\n# connette l'interfaccia WLAN alla rete Wifi SSID con chiave KEY\nwlan.connect('ssid', 'key')\n\nwhile not wlan.isconnected():\n    print(\"Connecting...\")\n    time.sleep(0.5)\n\nprint(\"CONNECTED\")\nprint(\"Network settings:\", wlan.ifconfig())\n</code></pre> <p>Bene! Adesso impostiamo manualmente le informazioni di rete</p> Connessione ad una rete WIFI con indirizzamento statico<pre><code>import network\nimport time\n\nwlan = network.WLAN(network.STA_IF)\nwlan.active(True)\n\n# connette l'interfaccia WLAN alla rete Wifi SSID con chiave KEY\nwlan.connect('ssid', 'key')\n\n# configurazione di rete: Questi numeri potrebbero funzionare a scuola, con una opportuna x fra 1 e 254\nwlan.ifconfig( ('10.10.12.x','255.255.0.0','10.10.0.1','8.8.8.8') )\n\nwhile not wlan.isconnected():\n    print(\"Connecting...\")\n    time.sleep(0.5)\n\nprint(\"CONNECTED\")\n</code></pre>"},{"location":"corso/99_network/#creare-una-rete-wifi-ad-hoc","title":"Creare una rete Wifi Ad-hoc","text":"<p>Il codice che presentiamo adesso serve invece a configurare l'interfaccia WLAN per creare una propria rete Wifi, a cui evetualmente far connettere altri dispositivi.</p> <p>Vediamo il codice:</p> <pre><code>import network\n\n# crea l'oggetto interfaccia WLAN con opzione network.AP_IF\nwlan = network.WLAN(network.AP_IF)\n\n# Imposta il nome (si chiama SSID) della rete Wifi\nwlan.config(ssid='NomeReteWifi')\n# oppure\nwlan.config(ssid='NomeReteWifi' , security=3 , key=\"PasswordReteWifi\")\n\n# attivala\nwlan.active(True)\n</code></pre> <p>L'IP predefinito in modalit\u00e0 Access Point \u00e8 <code>192.168.4.1</code>. I client connessi partono da <code>.2</code>.</p> <p>Se voleste elencare i client connessi...</p> <pre><code>while True:\n    clients = ap.status(\"stations\")\n    print(f\"[WIFI] {len(clients)} stations connected\")\n    for mac in clients:\n        for m in mac:\n            smac = f\"{m[0]:02x}:{m[1]:02x}:{m[2]:02x}:{m[3]:02x}:{m[4]:02x}:{m[5]:02x}\"\n            print(f\"[WIFI] Station connected: {smac}\")\n\n    time.sleep(1)\n</code></pre>"},{"location":"corso/99_network/#webrepl","title":"WebREPL","text":"<p>Tip</p> <p><code>REPL</code> sta per <code>Read Evaluate Print Loop</code> e non \u00e8 nient'altro che il nome tecnico del prompt dei comandi di Python. Sarebbe quella cosina dopo i 3 maggiori (<code>&gt;&gt;&gt;</code>) che permette il pi\u00f9 velocemente possibile di eseguire un comando o di controllare il valore di una variabile.</p> <p>Per accedere al prompt di MicroPython ci sono due modi:</p> <ol> <li> <p>collegando l'esp32 tramite USB al PC e interfacciandosi sulla porta virtuale seriale che si crea automaticamente. (Su Windows, sono le porte COM + un numero; su Linux e Mac, le porte ttyUSB + un numero).</p> </li> <li> <p>collegandosi tramite wifi alla cosiddetta <code>WebREPL</code>.</p> </li> </ol> <p>Ovviamente noi qui ci occupiamo del secondo caso. Alcune piccole precisazioni preliminari:</p> <ul> <li> <p>per connetterci alla <code>WebREPL</code> dobbiamo prima di tutto essere collegati al wifi (e fino a qui...)</p> </li> <li> <p>per instaurare una connessione alla <code>WebREPL</code> dell'esp32 occorre un <code>WebREPL Client</code>. Neanche a dirlo... <code>Thonny</code> ne ha uno incluso al suo interno... senza dover fare nulla!!!</p> </li> </ul> <p>Per utilizzare <code>WebREPL</code> dobbiamo prima di tutto configurarlo al meglio! Digitate nel prompt il seguente comando:</p> <pre><code>import webrepl_setup\n</code></pre> <p>Abilitate l'esecuzione automatica all'avvio e scegliete la password di accesso.</p> <p>Note</p> <p>Facciamola facile!!! Mettiamo tutti la password <code>esp32</code>. </p> <p>Ci sar\u00e0 tempo per fare l'hardening del nostro sistema. Adesso favoriamo la semplicit\u00e0 di configurazione!!!</p> <p>Warning</p> <p>Terminata la configurazione webrepl dell'esp32, apparir\u00e0 nel suo filesystem un file chiamato <code>webrepl_cfg.py</code>, contenente, tra le altre cose, la password selezionata!</p> <p>Non dovete toccarlo, modificarlo, cancellarlo... niente!!!</p> <p>Altrimenti tutto risulter\u00e0 perfettamente inutile...</p> <p>Una volta individuato l'IP del vostro sistema riavviate l'esp32 e procedete a connettervi tramite <code>WebREPL</code>. Ecco le operazioni da fare su Thonny:</p> <p>Sulle opzioni...</p> <p></p> <p>Infine, quando avete riavviato l'esp32, provate a connettervi selezionando il prompt corretto.</p> <p></p>"},{"location":"corso/99_network/#web-server","title":"Web Server","text":"<p>Un semplice esempio di web server, per poter studiare e modificare un pochino il codice, per accendere e spegnere il led di sistema dell'ESP32</p> <pre><code># THE led\nimport machine\nled = machine.Pin(5, machine.Pin.OUT)\nled.off()\n\n# THE web server\nimport socket\n\n# ....\nserver = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nserver.bind(('0.0.0.0', 80))\nserver.listen(8) # max number of simultaneous connections\nserver.setblocking(False)\n\nwhile True:\n    conn, addr = server.accept()\n    print('Got a connection from ', str(addr))\n\n    request = str( conn.recv(1024) )\n    request_line = request.split('\\n')[0]\n\n    if 'led=on' in request_line:\n        print('LED ON')\n        led.on()\n    if 'led=off' in request_line:\n        print('LED OFF')\n        led.off()\n\n    html = \"\"\n    html += '&lt;h1&gt;Web LED&lt;/h1&gt;' \n    html += '&lt;a href=\"/?led=on\"&gt;&lt;button class=\"button\"&gt;ON&lt;/button&gt;&lt;/a&gt;'\n    html += '&lt;a href=\"/?led=off\"&gt;&lt;button class=\"button button2\"&gt;OFF&lt;/button&gt;&lt;/a&gt;'\n\n    conn.send('HTTP/1.1 200 OK\\n')\n    conn.send('Content-Type: text/html\\n')\n    conn.send('Connection: close\\n\\n')\n    conn.sendall(html)\n    conn.close()\n</code></pre>"},{"location":"corso/99_network/#async-web-server","title":"Async Web Server","text":"<p>Questo codice \u00e8 sperimentale. L'ho scritto durante le vacanze di Natale... </p> <pre><code>import asyncio\nimport socket\n\nasync def handle_client(client):\n    loop = asyncio.get_event_loop()\n\n    request = (await loop.sock_recv(client, 1024)).decode('utf8')\n    request_line = request.split('\\n')[0]\n    print(\"request line:\", request_line)\n\n    reply = ''\n    reply += 'HTTP/1.1 200 OK\\n'\n    reply += 'Content-Type: text/html\\n'\n    reply += 'Connection: close\\n\\n'\n\n    if 'led=on' in request_line:\n        print('LED ON')\n    if 'led=off' in request_line:\n        print('LED OFF')\n\n    reply += '&lt;h1&gt;Web LED&lt;/h1&gt;' \n    reply += '&lt;a href=\"/?led=on\"&gt;&lt;button class=\"button\"&gt;ON&lt;/button&gt;&lt;/a&gt;'\n    reply += '&lt;a href=\"/?led=off\"&gt;&lt;button class=\"button button2\"&gt;OFF&lt;/button&gt;&lt;/a&gt;'\n    reply += '\\n'\n\n    await loop.sock_sendall(client, reply.encode('utf8'))\n    client.close()\n\nasync def run_server():\n    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    server.bind(('0.0.0.0', 8080))\n    server.listen(8) # max number of simultaneous connections\n    server.setblocking(False)\n\n    loop = asyncio.get_event_loop()\n\n    while True:\n        client, addr = await loop.sock_accept(server)\n        loop.create_task(handle_client(client))\n\n# -----------------------------------------------------------------------------\nif __name__ == \"__main__\":\n    asyncio.run(run_server())\n</code></pre>"},{"location":"corso/99_network/#bluetooth","title":"Bluetooth","text":"<p>Quando arriva, arriva...</p> <p> </p>"},{"location":"tutorials/00_intro/","title":"I Tutorial","text":"<p>In questa sezione troverete alcune esperienze singole per sviluppare una tematica specifica.</p> <p>Attenzione!!! Potrebbe essere interessante... o perfino divertente...</p> <p> </p>"},{"location":"tutorials/04_simulator/","title":"Esp32 Simulator","text":"<p>Per poter lavorare con i dispositivi ESP32 e tutti i sensori anche da casa o in generale, senza apparecchiare tutto il laboratorio di materiale, \u00e8 possibile ricorrere ad uno dei tanti progetti di simulazione dell'hardware. </p> <p>Quello che ha pi\u00f9 colpito la nostra attenzione si chiama https://wokwi.com/ ed  \u00e8 una applicazione web per la simulazione di progetti IoT direttamente nel browser.</p>"},{"location":"tutorials/04_simulator/#istruzioni-operative","title":"Istruzioni Operative","text":"<p>Suggerimento</p> <p>Le seguenti istruzioni valgono per lavorare su un dispositivo virtuale il pi\u00f9 possibile identico all'esp32 che abbiamo a scuola.</p> <p>I prof stanno lavorando per renderlo disponibile di default su wokwi!!!</p> <ol> <li> <p>Scarica il seguente file zip ed estrai la cartella <code>esp32-wroom-32</code> sul tuo computer</p> </li> <li> <p>Clicca qui per creare un nuovo progetto</p> </li> <li> <p>Premi <code>F1</code> sull'editor e nella tendina di selezione cerca \"Load custom board file...\"</p> </li> <li> <p>Carica la cartella <code>esp32-wroom-32</code> scaricata precedentemente.</p> </li> <li> <p>Modifica il file <code>diagram.json</code> in questo modo:</p> file diagram.json modificato<pre><code>{\n  \"version\": 1,\n  \"author\": \"il tuo nome e cognome\",\n  \"editor\": \"wokwi\",\n  \"parts\": [\n    {\n      \"type\": \"wokwi-custom-board\",\n      \"id\": \"esp\",\n      \"attrs\": { \"env\": \"micropython-20231227-v1.22.0\" }\n    }\n  ],\n   \"connections\": [\n     [ \"esp:TX\", \"$serialMonitor:RX\", \"\", [] ],\n     [ \"esp:RX\", \"$serialMonitor:TX\", \"\", [] ]\n   ],\n  \"dependencies\": {}\n}\n</code></pre> </li> <li> <p>Salva e sei pronto all'azione!! (indica il nome del tuo progetto! Ad esempio, ProvaLED)</p> </li> <li> <p>Modifica il tuo progetto hardware aggiungendo led, resistenze, collegamenti e tutto quanto necessario</p> </li> <li> <p>Scrivi il codice nell'editor online (file <code>main.py</code>) e testalo avviando l'esp32 virtuale.</p> </li> <li> <p>Quando hai finito, scarica il progetto (file <code>ProvaLED.zip</code>, contenente almeno i file <code>main.py</code> e <code>diagram.json</code>) dal men\u00f9 in alto, facendo <code>Download project.zip</code></p> </li> <li> <p>Consegna i compiti inviando il file <code>zip</code> al docente!</p> </li> </ol> <p>Adesso non hai pi\u00f9 alcuna scusa per non fare i compiti a casa!!!</p> <p> </p>"},{"location":"tutorials/10_socket/","title":"Socket Programming","text":"<p>I socket sono oggetti software gestiti dal Sistema Operativo. Sono gli unici responsabili per qualunque connessione di rete. Anzi... pi\u00f9 precisamente una connessione di rete non \u00e8 altro che uno scambio di dati fra due socket! E chi chiede al sistema operativo di creare i socket? Le applicazioni!!!</p> <p>I socket permettono anche ai dispositivi di veicolare contemporaneamente pi\u00f9 connessioni logiche (ad esempio, due schede di un browser aperte) attraverso un'unica connessione fisica! Pi\u00f9 precisamente, per ogni dispositivo fisico di connessione alla rete sono disponibili 65.536 porte logiche  per la possibile creazione di altrettanti socket!</p> <p></p> <p></p> <p></p> <p>Come si evince chiaramente dalla figura, Ogni socket si individua grazie alla coppia di informazioni: <code>IP</code>, <code>PORTA LOGICA</code>.</p> <p>Ogni connessione alla rete viene individuata univocamente (nell'unit\u00e0 di tempo) dalla coppia di socket  che fanno da mittente e destinatario della stessa. </p> <p>Il livello di trasporto pu\u00f2 fornire due tipi di servizi, definiti in due protocolli diversi:</p> <ul> <li>Il protocollo TCP, per le connessioni punto a punto (1 a 1); connesso e affidabile</li> <li>Il protocollo UDP per le connessioni semplici (anche broadcast e multicast) senza alcuna sovrastruttura: non connesso e non affidabile.</li> </ul> <p>Ok... la teoria la sappiamo! Vediamo il codice adesso.</p>"},{"location":"tutorials/10_socket/#socket-in-python","title":"Socket in Python","text":"<p>Come dicevamo, i socket sono oggetti software gestiti dal Sistema Operativo e invocati dalle applicazoini. Come si crea un socket in Python??</p> <pre><code>import socket\n\n# Oggetto Socket TCP\ntcp_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n\n# Oggetto Socket UDP\nudp_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n</code></pre> <p>Anche qui... non mi sembra complicato :)</p> <p>Faremo adesso una prova di comunicazione client-server tramite il protocollo UDP.</p>"},{"location":"tutorials/10_socket/#comunicazione-clientserver-udp-in-python","title":"Comunicazione client/server UDP in Python","text":"<p>Vediamo il codice che crea un server con il protocollo UDP. Questo semplice programma si mette in attesa di comunicazioni. Poi a seconda del messaggio arrivato risponde OK se il numero di lettere arrivate \u00e8 pari, ERR se sono dispari.</p> UDP Server in Python<pre><code>import socket\nimport time\n\nlocalIP = \"192.168.110.200\"  # Qui ci va il tuo IP, come stringa\nlocalPort = 20000            # Qui ci va una porta (&gt; 1024), come intero\n\n# UDP Socket Object\nudp_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n\n# Bind to address and ip\nudp_socket.bind( (localIP, localPort) )\n\nprint(\"UDP server up and listening\")\n\n# Listen for incoming datagrams\nwhile True:\n    message,address = udp_socket.recvfrom(1024)\n\n    time.sleep(0.1)\n    print(\"Message from Client:\", message.decode() )\n    print(\"Client IP Address:\", address)\n\n    msgFromServer = \"OK\"\n    if len(message) % 2 == 1:\n        msgFromServer = \"Err\"\n    bytesToSend = str.encode(msgFromServer)\n\n    # Sending a reply to client\n    udp_socket.sendto(bytesToSend, address)\n</code></pre> <p></p> <p>Ovviamente abbinato al server, che deve essere in esecuzione, ci va un client che deve tentare la connessione e l'invio allo stesso. Ecco il codice che permette di inviare al server un messaggio qualunque.</p> <p></p> UDP Client in Python<pre><code>import socket\nimport time\n\nServer_IP   = \"192.168.110.200\"  # Qui ci va l'IP del dispositivo che esegue il tuo server, come stringa\nServer_PORT = 20000              # Qui ci va la porta del tuo server (la devi sapere), come intero\n\nMESSAGE = input(\"text to send: \")\n\nprint(\"UDP target IP: \", Server_IP)\nprint(\"UDP target port: \", Server_PORT)\nprint(\"message: \", MESSAGE)\n\n# UDP Socket Object\nudp_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\nudp_socket.sendto(MESSAGE.encode(), (Server_IP, Server_PORT))\n\ntime.sleep(0.1)\n\nmessage,address = udp_socket.recvfrom(1024)\n\nprint(\"Reply from Server:\", message.decode() )\nprint(\"Server IP Address:\", address)\n</code></pre> <p>Adesso basta solo provare :)</p>"},{"location":"tutorials/10_socket/#comunicazione-clientserver-tcp-in-python","title":"Comunicazione client/server TCP in Python","text":"<p>TCP \u00e8 un protocollo ben pi\u00f9 complicato di UDP! Vi espongo le differenze fondamentali:</p> <ul> <li>il socket del server, prima di poter ricevere connessioni, dovr\u00e0 porsi in modalit\u00e0 <code>listen</code></li> <li>il client, prima di poter inviare dati al server, dovr\u00e0 stabilire una <code>connessione</code> con il socket del server</li> <li>Una volta stabilita la connessione, i dati tra i due socket saranno veicolati tramite essa, con i metodi <code>sendall</code> e <code>recv</code></li> <li>I dati di passaggio nella connessione sono per forza di cose ordinati! (A questo ci pensa TCP... noi non dobbiamo fare nulla. Solo sapere...)</li> <li>Alla fine dello scambio di dati la connessione va chiusa con il metodo <code>close</code> da parte di entrambi i socket!!!</li> </ul> <p>Vediamo un esempio di codice che implementa un semplice client e un semplice server basati su TCP. Il client potr\u00e0 inviare qualsiasi messaggio vuole, mentre il server risponder\u00e0 comunque ok. Se il client invia la stringa close il server saluta con bye e chiude la connessione.</p> Simple Python TCP server<pre><code>import socket\n\nHOST = \"127.0.0.1\"  # Standard loopback interface address (localhost)\nPORT = 65432        # Port to listen on (non-privileged ports are &gt; 1023)\n\ntcp_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n\ntcp_socket.bind( (HOST, PORT) )\ntcp_socket.listen()\n\nprint(f\"listening on socket ({HOST}:{PORT})...\")\n\nconn, addr = tcp_socket.accept()\n\nif conn:\n    print(f\"Connected by {addr}\")\n\n    while True:\n        data = conn.recv(1024)\n        message = data.decode()\n        print(\"Received:\", message)\n        if message == \"close\":\n            conn.sendall( \"bye\".encode() )\n            break\n        conn.sendall( \"OK\".encode() )\n\nconn.close()\n</code></pre> <p>Qui sotto invece trovate il codice che implementa il client TCP.</p> Simple Python TCP client<pre><code>import socket\n\nHOST = \"127.0.0.1\"  # The server's hostname or IP address\nPORT = 65432  # The port used by the server\n\ntcp_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\ntcp_socket.connect( (HOST, PORT) )\n\nwhile True:\n    message = input(\"Message to send: \")\n\n    tcp_socket.sendall( message.encode() )\n    data = tcp_socket.recv(1024)\n    message = data.decode()\n    print(f\"Received: {data.decode()}\")\n\n    if message == \"bye\":\n        tcp_socket.close()\n        break\n</code></pre> <p> </p>"},{"location":"tutorials/20_tello/","title":"Tello SDK","text":"<p>Per affrontare questo tutorial sar\u00e0 necessario aver affrontato il tutorial su socket e network programming.</p> <p>Un <code>Software Development Kit</code> \u00e8 un insieme di strumenti (un Kit, appunto) che permette di sviluppare software relativo ad un tema specifico. Pu\u00f2 contenere un insieme di librerie specifiche per lo sviluppo, una documentazione specifica, un insieme di strumenti per sviluppare software e molto altro.</p> <p>Il <code>Tello SDK</code> \u00e8 sostanzialmente un documento che spiega come collegarsi al drone da remoto, come inviargli comandi e quali risposte aspettarsi da esso.</p> <p>Per adesso, non far\u00f2 altro che mettere un link al documento</p> <p>Buona lettura!!</p> <p> </p>"},{"location":"tutorials/30_pyserial/","title":"PySerial","text":"<p>Blah blah...</p> <p> </p>"}]}